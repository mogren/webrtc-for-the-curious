<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>はじめに on 好奇心旺盛な人のためのWebRTC</title><link>https://webrtcforthecurious.com/ja/</link><description>Recent content in はじめに on 好奇心旺盛な人のためのWebRTC</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://webrtcforthecurious.com/ja/index.xml" rel="self" type="application/rss+xml"/><item><title>何を、なぜ、どのように</title><link>https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/</guid><description>WebRTCとは？ # WebRTC とは、Web Real-Time Communication の略で、API であると同時にプロトコルでもあります。WebRTC プロトコルは、2 つの WebRTC エージェントが双方向の安全なリアルタイム通信をネゴシエートするための一連のルールです。WebRTC API は、開発者が WebRTC プロトコルを使用するためのものです。WebRTC API は、JavaScript のみで規定されています。
似たような関係として、HTTP と fetch API があります。プロトコルとしての WebRTC が HTTP で、API としての WebRTC が fetch API となります。
WebRTC プロトコルは、JavaScript 以外の API/言語でも利用可能です。また、WebRTC 用のサーバーやドメイン固有のツールもあります。これらの実装はすべて WebRTC プロトコルを使用しているため、相互にやりとりできます。
WebRTC プロトコルは、IETF のrtcwebというワーキンググループで管理されています。WebRTC API は、W3C のwebrtc-pcで文書化されています。
なぜWebRTCを学ぶ必要があるのか？ # WebRTC を使うことで得られるものは以下の通りです。このリストはすべてを網羅しているわけではありませんが、あなたが旅をしている間に感謝することもあるでしょう。これらの用語のいくつかをまだ知らなくても、この本が教えてくれますのでご安心ください。
オープンスタンダード 複数の実装 ブラウザで利用可能 必須の暗号化 NAT トラバーサル 既存技術の再利用 輻輳（ふくそう）制御 1秒未満のレイテンシー WebRTCプロトコルは他の技術の集合体である # これは、本 1 冊分の説明が必要なテーマです。しかし、ここでは 4 つのステップに分けて説明します。</description></item><item><title>シグナリング</title><link>https://webrtcforthecurious.com/ja/docs/02-signaling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/02-signaling/</guid><description>WebRTCシグナリングとは？ # WebRTC エージェントを作成したとき、エージェントは他のピアについて何も知りません。誰と接続しようとしているのか、何を送ろうとしているのか、全くわかりません。 シグナリングは、通話を可能にする最初のブートストラップです。これらの値が交換されると、WebRTC エージェントはお互いに直接通信できるようになります。
シグナリングメッセージは単なるテキストです。WebRTC エージェントは、メッセージの転送方法を気にしません。一般的には WebSocket で共有されますが、これは必須ではありません。
WebRTC のシグナリングはどのように動作しますか？ # WebRTC は、Session Description Protocol と呼ばれる既存のプロトコルを使用しています。このプロトコルにより、2 つの WebRTC エージェントは、接続を確立するために必要なすべての状態を共有します。このプロトコル自体は、読んで理解するのは簡単です。 複雑なのは、WebRTC がこのプロトコルに入力するすべての値を理解することです。
このプロトコルは WebRTC 固有のものではありません。WebRTC の話をしなくても、まず Session Description Protocol を学びます。WebRTC はこのプロトコルのサブセットを実際に利用するだけなので、ここでは必要なものだけを取り上げます。 プロトコルを理解した後は、WebRTC での応用的な使い方に進みます。
Session Description Protocol (SDP)とは？ # SDP は、RFC 4566で定義されています。SDP はキーと値で構成されるプロトコルで、各値の後には改行が入ります。これは、INI ファイルに似ています。 Session Description は、0 個以上のメディア記述を含みます。頭の中では、Session Description にメディア記述の配列が含まれているようにモデル化できます。
メディア記述は通常、メディアの 1 つのストリームに対応しています。つまり、3 つのビデオストリームと 2 つのオーディオトラックを持つ通話を記述したい場合、5 つのメディア記述が必要になります。
SDPの読み方 # Session Description の各行は、1 つの文字で始まります。その後、等号が続きます。この等号以降が値となります。値が完了すると、改行されます。
SDP では、有効なキーをすべて定義しています。プロトコルで定義されているキーには、文字しか使用できません。これらのキーにはすべて重要な意味がありますが、それについては後ほど説明します。
Session Description の例を見てみましょう。</description></item><item><title>接続</title><link>https://webrtcforthecurious.com/ja/docs/03-connecting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/03-connecting/</guid><description>なぜWebRTCには接続用の専用サブシステムが必要なのでしょうか？ # 現在導入されているほとんどのアプリケーションは、クライアント/サーバー接続を確立しています。クライアント/サーバー接続では、サーバーが安定した周知のトランスポートアドレスを持っている必要があります。クライアントはサーバーにコンタクトし、サーバーはそれに応答します。
WebRTCは、クライアント/サーバーモデルを使用せず、ピアツーピア（P2P）接続を確立します。P2P接続では、接続を作成するタスクが両方のピアに均等に分配されます。これは、WebRTCのトランスポートアドレス（IPとポート）は想定できず、セッション中に変更される可能性もあるためです。WebRTCはできる限りの情報を収集し、2つのWebRTCエージェント間の双方向通信を実現するために多大な努力をします。
しかし、ピアツーピアの接続を確立するのは難しいことです。これらのエージェントは、直接接続されていない異なるネットワークに存在する可能性があります。直接的な接続性が存在する場合でも、別の問題が発生することがあります。クライアントが異なるプロトコル (UDP &amp;lt;-&amp;gt; TCP) や、IPバージョン (IPv4 &amp;lt;-&amp;gt; IPv6) を利用している場合もあります。
このようにP2P接続の設定が難しいにもかかわらず、WebRTCには以下のような特徴があるため、従来のクライアント/サーバー技術よりも有利になります。
帯域幅コストの削減 # メディアの通信はピア間で直接行われるため、メディアを中継するために別のサーバーを用意する必要がありません。
遅延の低減 # 通信は直接行われる方が速いです。ユーザーが全ての通信をサーバーを経由して行うと、通信速度が低下します。
安全なE2E通信 # 直接通信の方が安全です。ユーザーはサーバーを経由せずにデータを送信するので、ユーザーはサーバーがデータを解読しないことを信じる必要はありません。
どうやって使うの？ # 上記のプロセスは、Interactive Connectivity Establishment (ICE)と呼ばれています。WebRTCよりも前のプロトコルです。
ICEは、2つのICE Agent間の通信に最適な方法を見つけようとするプロトコルです。各ICEエージェントは、到達可能な方法を公開しており、これを候補と呼びます。候補とは、基本的に、相手が到達できると考えられるエージェントのトランスポートアドレスです。ICEは、候補の中から最適な組み合わせを決定します。
ICEの実際のプロセスについては、本章の後半で詳しく説明します。WebRTC がネットワークにおけるどのような挙動を克服しようとしているかを理解すると、ICEが存在する理由を理解できます。
ネットワークの現実的な制約 # ICEは、実世界のネットワークの制約を克服するためのものです。解決策を探る前に、実際の問題点について説明します。
同じネットワークにいない # ほとんどの場合、相手の WebRTC エージェントは同じネットワーク内にいるとは限りません。典型的な通話は、通常、直接接続されていない異なるネットワークにある2つのWebRTC Agent間で行われます。
下の図は、公衆インターネットで接続された2つの異なるネットワークのグラフです。各ネットワークには2つのホストがあります。
同一ネットワーク内のホストは、非常に簡単に接続できます。 192.168.0.1 -&amp;gt; 192.168.0.2 の間の通信は簡単にできます。これらの2つのホストは、外部の助けを借りずにお互いに接続できます。
しかし、 ルーターB を使っているホストは、 ルーターA の後ろにあるものに直接アクセスする方法がありません。 ルーターA の後ろにある 191.168.0.1 と ルーターB の後ろにある同じIPの違いをどうやって見分けるのでしょうか？これらはプライベートIPです。 ルーターB を使用しているホストは、 ルーターA に直接トラフィックを送信できますが、リクエストはそこで終了します。ルーターAはどのホストにメッセージを転送すべきか、どうやって知るのでしょうか?</description></item><item><title>セキュリティ対策</title><link>https://webrtcforthecurious.com/ja/docs/04-securing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/04-securing/</guid><description>WebRTCにはどんなセキュリティがありますか？ # WebRTCの接続はすべて認証され、暗号化されています。第三者があなたの送信内容を見たり、偽のメッセージを挿入したりすることはないので安心です。また、Session Description を生成したWebRTCエージェントが、通信相手であることも確かです。
誰もこれらのメッセージに手を加えないことが非常に重要です。第3者が転送中の Session Description を読んでも問題ありません。しかし、WebRTCには Session Description が変更されることに対する保護がありません。攻撃者は ICE Candidates を変更し、証明書フィンガープリントを更新することで、あなたに対して中間者攻撃を行うことができます。
どのような仕組みになっているのですか？ # WebRTCは、Datagram Transport Layer Security (DTLS)とSecure Real-time Transport Protocol (SRTP)という2つの既存のプロトコルを使用しています。
DTLSは、セッションをネゴシエートした後、2つのピア間で安全にデータを交換できます。DTLSは、HTTPSを実現する技術であるTLSと兄弟関係にありますが、DTLSはトランスポート層としてTCPではなくUDPを使用します。つまり、このプロトコルは、信頼性の低い配信を処理しなければならないということです。SRTPは、特にメディアを安全に交換するために設計されています。DTLSの代わりにSRTPを使用することで、いくつかの最適化が可能になります。
DTLSは最初に使用されます。ICEが提供する接続に対してハンドシェイクを行います。DTLSはクライアント/サーバー型のプロトコルなので、ハンドシェイクはどちらか一方が開始する必要があります。クライアント／サーバーの役割は、シグナリング時に選択されます。DTLSのハンドシェイクでは、双方が証明書を提示します。 ハンドシェイクが完了すると、この証明書は Session Description にある証明書のハッシュ値と比較されます。これは、ハンドシェイクが期待していたWebRTCエージェントで行われたことを確認するためです。これで、DTLS 接続が DataChannel の通信に使用できるようになります。
SRTPセッションを作成するには、DTLSで生成されたキーを使用してセッションを初期化します。SRTPにはハンドシェイク機構がないため、外部の鍵を使ってブートストラップを行う必要があります。これが完了すると、SRTP で暗号化されたメディアを交換できます。
セキュリティ101 # 本章で紹介する技術を理解するには、まずこれらの用語を理解する必要があります。暗号は難しいテーマなので、他の資料も参考にしてください。
暗号 # 暗号とは、平文を暗号文に変換する一連の手順のことです。その後、暗号を元に戻すことができるため、暗号文を平文に戻すことができます。暗号は通常、その動作を変えるための鍵を持っています。別の用語では、暗号化と復号化があります。
簡単な暗号はROT13です。各文字が13文字分前に移動します。暗号を解除するには、13文字を後ろに移動します。平文のHELLOは暗号文のURYYBになります。この場合、暗号はROT、鍵は13となります。
平文/暗号文 # 平文とは暗号の入力である。暗号文とは、暗号の出力である。
ハッシュ # ハッシュは、ダイジェストを生成する一方通行のプロセスです。入力があると、毎回同じ出力を生成します。出力が可逆的でないことが重要です。出力があれば、その入力を特定できないようにする必要があります。ハッシュ化は、メッセージが改ざんされていないことを確認したい場合に有効です。
単純なハッシュは、1文字おきに取るだけのもので、HELLOはHLOになります。「HELLO」が入力であると仮定することはできませんが、「HELLO」が一致することは確認できます。
公開鍵/秘密鍵暗号方式 # 公開鍵/秘密鍵暗号方式は、DTLS と SRTP が使用する暗号の種類を説明します。このシステムでは、公開鍵と秘密鍵の2つの鍵を持ちます。公開鍵は、メッセージを暗号化するためのもので、共有しても安全です。 秘密鍵は復号化のためのもので、決して共有してはいけません。公開鍵で暗号化されたメッセージを復号化できる唯一の鍵です。
ディフィー・ヘルマン交換 # ディフィー・ヘルマン交換は、初対面の2人のユーザがインターネット上で安全に共有秘密を作成できます。ユーザAは、盗聴の心配をすることなく、ユーザBに秘密を送ることができます。これは、離散対数問題を解く難しさによります。 この仕組みを完全に理解する必要はありませんが、これがDTLSのハンドシェイクを可能にしていることを知っておくと役立ちます。</description></item><item><title>リアルタイム・ネットワーキング</title><link>https://webrtcforthecurious.com/ja/docs/05-real-time-networking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/05-real-time-networking/</guid><description>リアルタイム・コミュニケーションにおいて、なぜネットワークが重要なのか？ # ネットワークは、リアルタイム通信を制限する要素です。理想的な世界では、帯域幅が無限にあり、パケットは瞬時に到着します。しかし、実際にはそうではありません。ネットワークには限界があり、いつでも条件が変わる可能性があります。また、ネットワークの状態を測定・観察することも難しい問題です。ハードウェア、ソフトウェア、そしてその構成によって、さまざまな挙動を示すことがあります。
また、リアルタイムでの通信は、他の領域にはない問題です。Web制作者にとっては、ネットワークによってはWebサイトの表示が遅くなっても致命的ではありません。すべてのデータが届いていれば、ユーザーは満足です。WebRTCでは、データが遅れれば意味がありません。5秒前の電話会議の内容なんて誰も気にしません。そのため、リアルタイム通信システムを開発する際には、トレードオフの関係にならざるを得ません。制限時間は何秒か、どれだけ送れるか。
本章では、データ通信とメディア通信の両方に適用される概念を説明します。後の章では、理論的な説明にとどまらず、WebRTCのメディアサブシステムとデータサブシステムがこれらの問題をどのように解決するのかを説明します。
難しくしているネットワークの属性は何ですか？ # すべてのネットワークで効果的に機能するコードは複雑です。多くの異なる要因があり、それらがすべて微妙に影響し合います。開発者が遭遇する最も一般的な問題は以下の通りです。
帯域幅 # 帯域幅とは、特定のパスで転送できるデータの最大レートのことです。これは固定された数値ではないことを覚えておく必要があります。帯域幅は、利用者の増加（または減少）に伴い、経路に沿って変化します。
送信時間とラウンドトリップタイム # 送信時間とは、パケットが到着するまでの時間のことです。帯域幅と同様、これも一定ではありません。 送信時間は、いつでも変動する可能性があります。
伝送時間を計算するには、送信側と受信側の時計がミリ秒単位で同期している必要があります。 少しでもずれがあると、信頼性の低い伝送時間の測定になってしまいます。 WebRTCは非常に異質な環境で運用されているため、ホスト間の完全な時刻同期に頼ることはほとんど不可能です。
ラウンドトリップタイムの測定は、不完全なクロック同期の回避策です。
WebRTCのピアは、分散したクロックで動作する代わりに、自身のタイムスタンプ sendertime1 を含む特別なパケットを送信します。 協力しているピアがそのパケットを受信し、タイムスタンプを送信者に反映します。 オリジナルの送信者は、反映された時間を得ると、現在の時間 sendertime2 からタイムスタンプ sendertime1 を引きます。 この時間差を &amp;ldquo;往復伝搬遅延 &amp;ldquo;といい、より一般的にはラウンドトリップタイムといいます。
rtt = sendertime2 - sendertime1
ラウンド・トリップ・タイムの半分は、送信時間の十分な近似値と考えられます。 この回避策には欠点がないわけではありません。 この方法では、パケットの送信と受信にかかる時間が同じであることを前提としています。 しかし、携帯電話ネットワークでは、送信と受信の動作が時間的に対称でない場合があります。 お使いの携帯電話のアップロード速度は、ほとんどの場合、ダウンロード速度よりも低いことにお気づきかもしれません。
transmission_time = rtt/2
ラウンドトリップタイムの測定に関する技術的な内容は、RTCP送信者と受信者のレポートの章で詳しく説明されています。
ジッター # ジッターとは、「伝送時間」がパケットごとに異なることです。パケットが遅延しても、すぐに到着する可能性があります。
パケットロス # パケットロスとは、メッセージが送信中に失われることです。パケットロスは安定している場合もあれば、急激に発生する場合もあります。 これは、衛星やWi-Fiなどのネットワークの種類に起因します。衛星やWi-Fiなどのネットワークの種類に起因する場合もあれば、通信中のソフトウェアに起因する場合もあります。
最大伝送単位 # 最大伝送容量とは、1つのパケットの大きさの制限のことです。ネットワークでは、1つの巨大なメッセージを送信することはできません。プロトコルレベルでは、メッセージを複数の小さなパケットに分割する必要があるかもしれません。
MTUは、どのようなネットワーク経路をとるかによっても異なります。Path MTU Discoveryのようなプロトコルを使用して、送信可能な最大のパケットサイズを把握できます。
輻輳 (ふくそう) # 輻輳（ふくそう）とは、ネットワークの限界に達した状態のことです。これは通常、現在のルートが処理できる帯域のピークに達したことが原因です。また、ISPが設定した1時間ごとの制限のように、オペレータが課すものもあります。</description></item><item><title>メディア・コミュニケーション</title><link>https://webrtcforthecurious.com/ja/docs/06-media-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/06-media-communication/</guid><description>WebRTCのメディア通信では何ができるのですか？ # WebRTCでは、オーディオやビデオのストリームを無制限に送受信できます。これらのストリームは、通話中にいつでも追加・削除できます。これらのストリームはすべて独立していることもあれば、まとめて送信することもできます。例えば、自分のデスクトップのビデオフィードを送信し、ウェブカムからのオーディオ／ビデオを含めることができます。
WebRTCプロトコルは、コーデックに依存しません。基礎となるトランスポートは、まだ存在しないものも含めて、すべてをサポートしています。ただし、通信相手であるWebRTCエージェントが、それを受け入れるために必要なツールを持っていない場合もあります。
また、WebRTCは、動的なネットワーク状況に対応できるように設計されています。通話中に帯域が増えたり減ったりすることがあります。また、突然パケットロスが多発することもあります。WebRTCはこのような状況にも対応できるように設計されています。WebRTCはネットワークの状態に対応し、利用可能なリソースで最高の体験を提供しようとします。
どのような仕組みになっているのですか？ # WebRTCは、RFC 3550で定義されている2つの既存のプロトコルRTPとRTCPを使用しています。
RTP（Real-time Transport Protocol）は、メディアを伝送するプロトコルです。動画をリアルタイムに配信することを目的に設計されています。遅延や信頼性に関するルールは規定されていませんが、それらを実装するためのツールが提供されています。RTPはストリームを提供し、1つの接続で複数のメディアフィードを実行できます。また、メディアパイプラインに供給するために必要な、タイミングや順序の情報も提供します。
RTCP（RTP Control Protocol）は、コールに関するメタデータを通信するためのプロトコルです。このフォーマットは非常に柔軟で、必要なメタデータを追加できます。通話に関する統計情報を通信するために使用されます。また、パケットロスの処理や輻輳制御の実装にも使用されます。これにより、変化するネットワークの状況に対応するために必要な双方向の通信が可能になります。
レイテンシー vs クオリティ # リアルタイムメディアは、遅延と品質のトレードオフの関係にあります。遅延を許容すればするほど、高品質な映像が期待できます。
現実の制約 # これらの制約は、すべて現実世界の制約に起因するもので、お客様が克服しなければならないネットワークの特性です。
ビデオは複雑 # 動画の転送は簡単ではありません。30分の非圧縮720 8bitビデオを保存するには、約110Gb必要です。この数字では、4人での電話会議は不可能です。もっと小さくする方法が必要ですが、その答えは映像の圧縮です。しかし、これにはデメリットもあります。
ビデオ101 # ここでは、動画圧縮について詳しく説明しませんが、RTPがなぜこのように設計されているのかを理解するには十分です。動画圧縮とは、動画を新しいフォーマットにエンコードすることで、同じ動画をより少ないビット数で表現することです。
非可逆圧縮と可逆圧縮 # 動画のエンコードは、ロスレス（情報が失われない）とロッシー（情報が失われる可能性がある）の2種類があります。ロスレス圧縮の場合、相手に送るデータ量が多くなり、ストリームの遅延が大きくなったり、パケットの損失が多くなるため、RTPでは映像の品質が悪くなってもロッシー圧縮を行うのが一般的です。
イントラフレームとインターフレームの圧縮 # 動画の圧縮には2種類あります。1つ目はイントラフレームです。フレーム内圧縮では、1つのビデオフレームを記述するためのビットを削減します。静止画の圧縮にも同じ手法が使われており、JPEG圧縮法などがあります。
2つ目は、フレーム間圧縮です。動画は多くの画像で構成されているので、同じ情報を2度送らない方法を考えます。
フレーム間の種類 # フレームには3つの種類があります。
I-Frame - 完全な画像で、何もなくてもデコードできます。 P-Frame - 部分的な画像で、前の画像を修正したもの。 B-Frame - 部分的な画像で、以前の画像と未来の画像を組み合わせたもの。 3つのフレームタイプを視覚化すると以下のようになります。
動画はデリケート # 動画の圧縮は非常にステートフルであり、インターネットでの転送は困難です。I-Frameの一部が失われるとどうなるのか？P-Frameはどうやって修正すべき箇所を知るのでしょうか？映像圧縮がより複雑になるにつれ、この問題はさらに深刻になっています。幸いなことに、RTPとRTCPには解決策があります。
RTP # パケットフォーマット # すべてのRTPパケットは、以下のような構造になっています。</description></item><item><title>データ・コミュニケーション</title><link>https://webrtcforthecurious.com/ja/docs/07-data-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/07-data-communication/</guid><description>WebRTCのデータ通信で何が得られるのか？ # WebRTCは、データ通信のためのデータチャンネルを提供します。2つのピアの間では、65,534個のデータチャンネルを開くことができます。 データチャンネルはデータグラムをベースにしており、それぞれに耐久性の設定があります。デフォルトでは、各データチャネルには順序通りの配信が保証されています。
メディアの観点からWebRTCにアプローチしている場合、データチャネルは無駄に思えるかもしれません。HTTP や WebSocket を使用することができるのに、なぜこのようなサブシステム全体が必要なのでしょうか？
データチャネルの本当の強みは、UDP のように順序のない、または損失のある配信を行うように設定できることです。 これは、低レイテンシーでハイパフォーマンスの場合に必要です。バックプレッシャーを測定し、ネットワークがサポートする量だけを送信できます。
WebRTCはどのように動作するのですか？ # WebRTCは、RFC 2960で定義されているSCTP(Stream Control Transmission Protocol)を使用しています。SCTPはトランスポート層のプロトコルで、TCPやUDPの代替となることを目的としています。WebRTCでは、DTLS接続上で動作するアプリケーション層のプロトコルとして使用しています。
SCTPはストリームを提供し、各ストリームは独立して設定できます。WebRTCのデータチャネルは、それらを薄く抽象化したものに過ぎません。耐久性や順序に関する設定は、そのままSCTPエージェントに渡されます。
データチャネルには、チャネルラベルなど、SCTPでは表現できない機能があります。この問題を解決するために、WebRTCはRFC 8832で定義されているDCEP（Data Channel Establishment Protocol）を使用します。DCEPでは、通信を行うためのメッセージを定義しています。
DCEP # DCEPには、DATA_CHANNEL_OPENとDATA_CHANNEL_ACKの2つのメッセージしかありません。データチャネルが開かれるたびに、リモートはackで応答する必要があります。
DATA_CHANNEL_OPEN # このメッセージは、チャネルを開くことを望む WebRTC エージェントによって送信されます。
パケットフォーマット # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | Channel Type | Priority | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reliability Parameter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Label Length | Protocol Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \ \ / Label / \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \ \ / Protocol / \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ メッセージタイプ # メッセージタイプは、0x03の静的な値です。</description></item><item><title>応用WebRTC</title><link>https://webrtcforthecurious.com/ja/docs/08-applied-webrtc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/08-applied-webrtc/</guid><description>WebRTCの応用 # WebRTCの仕組みがわかったところで、いよいよWebRTCを使って構築してみましょう。この章では、WebRTC を使って人々が何をどのように構築しているかを探り、WebRTC で起こっている興味深いことをすべて学びます。WebRTC のパワーにはコストがかかります。プロダクショングレードの WebRTC サービスを構築することは困難です。本章では、そのような課題にぶつかる前に、その課題を説明します。
ユースケース別 # WebRTCは、Webブラウザ上で会議を行うための技術に過ぎないと多くの人が考えています。しかし、それだけではありません。 WebRTCはさまざまなユースケースに利用されています。常に新しいユースケースが登場しています。この章では、一般的なユースケースをいくつか挙げ、WebRTC がそれらにどのような変革をもたらしているかを説明します。
会議 # 会議は WebRTC の最初のユースケースです。このプロトコルには、他のプロトコルがブラウザで提供していないいくつかの必要な機能が含まれています。WebSocket で会議システムを構築しても、最適な条件であれば動作するかもしれません。現実のネットワーク環境で展開できるものを求めるのであれば、WebRTC が最適な選択です。
WebRTCは、メディアの輻輳制御とアダプティブ・ビットレートを提供します。ネットワークの状況が変化しても、ユーザーは最高の体験を得ることができます。開発者は、これらの条件を測定するために追加のコードを書く必要もありません。
参加者は、複数のストリームを送受信できます。また、それらのストリームはいつでも追加・削除できます。コーデックもネゴシエートされます。これらの機能はすべてブラウザが提供するもので、開発者がカスタムコードを書く必要はありません。
また、会議にはデータチャンネルの利点もあります。ユーザーはメタデータを送信したり、ドキュメントを共有できます。信頼性よりもパフォーマンスが必要な場合は、複数のストリームを作成して設定できます。
放送 # 放送業界では、WebRTC を利用した新しいプロジェクトが数多く登場しています。このプロトコルは、メディアの発行者と消費者の両方にとって多くの利点があります。
WebRTCはブラウザ上で動作するため、ユーザーは簡単に動画を公開できます。また、ユーザーが新しいクライアントをダウンロードする必要もありません。 ウェブブラウザがあれば、どんなプラットフォームでも動画を公開できます。パブリッシャーは、複数のトラックを送信し、いつでもそれらを修正／削除できます。これは、1つの接続につき1つのオーディオトラックと1つのビデオトラックしか許可されていなかった従来のプロトコルに比べて、大きな進歩です。
WebRTCは、開発者が遅延と品質のトレードオフをより細かくコントロールできるようにします。遅延が一定の閾値を超えないことがより重要な可能性があり、多少のデコードアーチファクトは許容したいと思うでしょう。メディアが到着したらすぐに再生するようにビューアを設定できます。TCP上で動作する他のプロトコルでは、これは簡単ではありません。ブラウザでは、データを要求してそれで終わりです。
リモートアクセス # リモートアクセスとは、WebRTC を使って他のコンピュータに遠隔でアクセスすることです。リモートホストを完全に制御することもできますし、単一のアプリケーションだけを制御することもできます。 これは、ローカルのハードウェアでは処理できないような、計算量の多いタスクを実行するのに適しています。例えば、新しいビデオゲームやCADソフトウェアの実行などです。WebRTCは、3つの方法でこの分野に革命をもたらしました。
WebRTCは、世界的にルーティングされていないホストへのリモートアクセスに使用できます。NATトラバーサルを使えば、STUN経由でしか利用できないコンピュータにアクセスできます。これは、セキュリティやプライバシーの面でも優れています。ユーザーは、ビデオをインジェストや「ジャンプボックス」に通す必要がありません。また、NATトラバーサルは導入を容易にします。ポートフォワーディングや固定IPの設定を事前に心配する必要がありません。
このシナリオでは、データチャネルも非常に強力です。最新のデータだけを受け付けるように設定できます。TCPの場合、Head-of-lineブロッキングが発生する危険性があります。古いマウスクリックやキープレスが遅れて到着すると、後続のデータが受け入れられなくなります。 WebRTCのデータチャネルはこの問題に対処するように設計されており、失われたパケットの再試行を行わないように設定できます。また、バックプレッシャを測定して、ネットワークがサポートする以上のデータを送信していないことを確認することもできます。
WebRTCがブラウザで利用できるようになったことで、生活の質が大きく向上しました。セッションを開始するために、専用のクライアントをダウンロードする必要はありません。WebRTCを搭載したクライアントはますます増えており、スマートテレビには完全なウェブブラウザが搭載されています。
ファイル共有と検閲回避 # ファイル共有と検閲回避は全く異なる問題です。しかし、WebRTCはこの2つの問題を同じように解決します。それは、どちらも簡単に利用でき、ブロックするのが難しくなるということです。
WebRTCが解決する最初の問題は、クライアントの獲得です。ファイル共有ネットワークに参加するには、クライアントをダウンロードする必要があります。ネットワークが分散されていても、まずクライアントを入手する必要があります。 制限されたネットワークでは、ダウンロードはしばしばブロックされます。ダウンロードできたとしても、ユーザーがクライアントをインストール/実行できない場合もあります。WebRTCはすべてのWebブラウザで利用可能なので、すぐに利用できます。
WebRTCが解決する2つ目の問題は、トラフィックがブロックされることです。ファイル共有や検閲回避を目的としたプロトコルを使用している場合、それをブロックするのは非常に簡単です。 WebRTCは汎用プロトコルなので、これをブロックするとすべての人に影響が及びます。WebRTCをブロックすると、ネットワークの他のユーザーが電話会議に参加できなくなる可能性があります。
IoT # IoTにはいくつかの異なるユースケースがあります。多くの人にとって、これはネットワークに接続されたセキュリティカメラを意味します。WebRTC を使用して、携帯電話やブラウザなどの他の WebRTC ピアにビデオをストリーミングできます。また、デバイスを接続してセンサーデータを交換するというユースケースもあります。LANに接続された2つのデバイスで、気候、騒音、光の測定値を交換できます。
WebRTCは、従来のビデオストリームプロトコルに比べて、プライバシーの面で非常に優れています。WebRTCはP2P接続をサポートしているので、カメラはビデオを直接ブラウザに送信できます。ビデオがサードパーティのサーバーに送られる必要はありません。ビデオが暗号化されていても、攻撃者は通話のメタデータから推測できます。
相互運用性は、IoT分野でのもう一つの利点です。WebRTCは、C#、C++、C、Go、Java、Python、Rust、TypeScriptなど、たくさんの異なる言語で利用できます。つまり、自分に最適な言語を使うことができるのです。また、2つの異なるクライアントを接続するために、独自のプロトコルやフォーマットを使用する必要もありません。
メディアプロトコルブリッジング # 既存のハードウェアとソフトウェアで動画を作成しているが、まだアップグレードできない。ユーザーが動画を見るために独自のクライアントをダウンロードすることを期待するのは不満です。そこで、WebRTC ブリッジを導入します。ブリッジは2つのプロトコルを変換するので、ユーザーは従来のセットアップでブラウザを使用できます。
開発者がブリッジするフォーマットの多くは、WebRTCと同じプロトコルを使用しています。SIPは一般的にWebRTCで公開されており、ユーザーはブラウザから電話をかけることができます。RTSPは、多くのレガシーセキュリティカメラで使用されています。どちらも同じ基本プロトコル（RTPとSDP）を使用しているので、計算コストをかけずに実行できます。ブリッジが必要なのは、WebRTC固有の機能を追加したり削除したりする場合だけです。
データプロトコルブリッジング # Web ブラウザは、限られたプロトコルしか使用できません。使えるのは、HTTP、WebSocket、WebRTC、QUIC です。それ以外のプロトコルに接続するには、プロトコルブリッジを使用する必要があります。プロトコルブリッジとは、外国のトラフィックをブラウザがアクセスできるものに変換するサーバーのことです。よくある例は、ブラウザからSSHを使ってサーバーにアクセスすることです。WebRTCのデータチャネルには、競合製品と比べて2つの利点があります。</description></item><item><title>デバッグ</title><link>https://webrtcforthecurious.com/ja/docs/09-debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/09-debugging/</guid><description>デバッグ # WebRTCのデバッグは、非常に困難な作業です。たくさんの可動部品があり、それらがすべて独立して壊れる可能性があります。注意していないと、間違ったものを探すために何週間もの時間を費やすことになります。やっと壊れた部品を見つけても、その原因を理解するためには、少し勉強する必要があります。
本章では、WebRTC をデバッグするための心構えを身につけます。問題をどのように分解するかを説明します。問題を把握した後は、一般的なデバッグツールを簡単にご紹介します。
問題の切り分け # デバッグの際には、問題がどこから発生しているのかを切り分ける必要があります。問題の始まりから始めてみましょう。
シグナリングの失敗 # ネットワーキングの失敗 # netcatを使ってSTUNサーバーをテストします。
20バイトのバインディングリクエストパケットを準備します。
echo -ne &amp;quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&amp;quot; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 の解釈を行います。
0001 はメッセージタイプ
00 00 はデータセクションの長さです。
21 12 a4 42 はマジック・クッキーです。
54 45 53 54 54 45 53 54 54 45 53 54 (ASCIIでは TESTTESTTEST とデコードされます)は12バイトのトランザクションIDです。</description></item><item><title>歴史</title><link>https://webrtcforthecurious.com/ja/docs/10-history-of-webrtc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/10-history-of-webrtc/</guid><description>歴史 # WebRTC を学ぶ際、開発者はその複雑さに苛立ちを覚えることがあります。WebRTC の機能が現在のプロジェクトとは無関係であることを知り、WebRTC がもっとシンプルであればと思うのです。問題は、使用例が人によって異なることです。リアルタイム通信には豊かな歴史があり、さまざまな人がさまざまなものを作ってきました。
本章では、WebRTC を構成するプロトコルの開発者へのインタビューを掲載しています。 それぞれのプロトコルを構築する際の設計について洞察し、最後に WebRTC そのものについてのインタビューを行います。ソフトウェアの意図や設計を理解すれば、そのソフトウェアを使ってより効果的なシステムを構築することができます。
RTP # RTP および RTCP は、WebRTC のすべてのメディア伝送を担当するプロトコルです。1996年1月にRFC 1889で定義されました。 著者の一人であるRon Frederickが自ら語ってくれるというのはとてもラッキーなことです。Ron は最近、RTPに影響を与えたプロジェクトであるNetwork Video toolを GitHub にアップロードしました。
彼自身の言葉です。
1992年10月、私はIPマルチキャストをベースにしたネットワークビデオ会議ツールを書こうと思い、Sun VideoPixフレームグラバーカードの実験を始めました。このプログラムは、LBLで開発されたオーディオ会議ツール「vat」をモデルにしたもので、会議に参加するユーザーに同様の軽量なセッションプロトコルを使用し、特定のマルチキャストグループにデータを送り、他のグループメンバーからのトラフィックを監視するだけのものでした。
このプログラムを成功させるためには、ネットワークに出す前にビデオデータを圧縮する必要がありました。私の目標は、家庭用ISDN回線の帯域幅である128kbps程度に収まる、見た目にも美しいデータストリームを作ることでした。さらに、その半分の帯域で見られるようなものを作りたかった。そのためには、画像サイズとフレームレートに応じて、約20倍の圧縮が必要でした。私はこの圧縮を実現し、使用した技術の特許を申請しました。これは後に特許US5485212Aとして認められました: 電話会議のためのソフトウェアビデオ圧縮。
1992年11月初旬、私はビデオ会議ツール「nv」を（バイナリ形式で）インターネットコミュニティに公開しました。初期テストの後、 このツールを使って、 11月のインターネット技術タスクフォースの一部を世界中にビデオキャストしました。15カ国の約200のサブネットでこの放送を受信することができ、1週間のうちに約50～100人が「nv」を使ってビデオを受信しました。
その後、オーストラリアの「NetWorkshop」、MCNCの「Packet Audio and Video」、スウェーデンの「MultiG Workshop on Distributed Virtual Realities」など、他の3つのワークショップやいくつかの小規模な会議でも「nv」を使ってインターネット全体に向けた放送が行われました。
1993年2月には「nv」のソースコードを公開し、3月にはウェーブレットベースの圧縮方式を導入したバージョンを公開しました。1993年5月には、カラービデオにも対応しました。
「nv」をはじめとするインターネット会議ツールのネットワークプロトコルは、インターネット技術タスクフォース（IETF）で標準化されたリアルタイム・トランスポート・プロトコル（RTP）をベースにしています。RFC 1889-1890で最初に発表され、その後RFC 3550-3551で改訂され、音声やビデオの特定フォーマットを伝送するためのプロファイルをカバーするさまざまな他のRFCも追加されました。
その後、数年にわたって「nv」の開発が続けられ、多くのハードウェアプラットフォームやビデオキャプチャーデバイスにツールが移植されました。当時、インターネット上で会議を中継するための主要なツールの一つとして使われ続け、NASAからシャトルミッションのライブ中継に選ばれたこともある。
1994年には、他社が開発したビデオ圧縮アルゴリズムを「nv」でサポートするようにした。これには、SunVideoビデオキャプチャカードがサポートするCellBフォーマットなどのハードウェア圧縮方式も含まれる。これにより、「nv」はCUSeeMeフォーマットでビデオを送信できるようになり、MacやPCでCUSeeMeを実行しているユーザーにビデオを送信できるようになりました。
「nv」が最後に公開されたのは、1994年7月にリリースされた「3.3beta」だった。私は「nv」をRTPプロトコルのバージョン2に移行させることを目的とした「4.0alpha」のリリースに取り組んでいましたが、私が他のプロジェクトに移ったため、この作業は完了しませんでした。4.0αのコードは、Network Video toolのアーカイブに含まれていますが、未完成であり、特にRTPv2のサポートが不完全であるなど、既知の問題があります。
「nv」で提供されたフレームワークは、後にXerox PARCの「Jupiter multi-media MOO」プロジェクトにおけるビデオ会議の基礎となり、後にMicrosoftに買収されたスピンオフ企業「PlaceWare」の基礎となりました。また、このコードは、高帯域幅のイーサネットやATMネットワーク上でNTSC放送品質のビデオを送ることができる多くのハードウェアビデオ会議プロジェクトの基礎としても使われました。 また、このコードの一部は、ネットワークベースのビデオ録画・再生サービスである「Mediastore」のベースとしても使用しました。
ドラフトに参加していた他のメンバーの動機やアイデアは覚えていますか？
私たちは皆、IPマルチキャストの研究者で、インターネット・マルチキャスト・バックボーン（通称MBONE）の構築に携わっていました。MBONEは、IPマルチキャストを最初に開発したスティーブ・デアリング、ヴァン・ジェイコブソン、スティーブ・キャスナーの3人によって作られました。スティーブ・デアリングと私はスタンフォード大学で同じ指導教官でしたが、スティーブはスタンフォード大学を辞めてXerox PARCで働くことになりました。私はインターンとしてXerox PARCでIPマルチキャスト関連のプロジェクトにひと夏を過ごし、スタンフォード大学在学中はパートタイムで、その後はフルタイムで働き続けました。ヴァン・ジェイコブソンとスティーブ・キャスナーは、ヘニング・シュルツリンと私と一緒に、初期のRTP RFCの4人の著者のうちの2人でした。私たちは皆、様々な形のオンラインコラボレーションを可能にするMBONEツールを開発していましたが、これらのツールが使用できる共通のベースプロトコルを作ろうとしたことがRTPにつながったのです。
マルチキャストはとても魅力的です。WebRTCは完全にユニキャストですが、その点について説明していただけますか？
スタンフォード大学に入学してIPマルチキャストについて学ぶ前、私はコンピュータを使って人々が互いにコミュニケーションを取る方法について長い間研究してきました。私は80年代初頭にダイアルアップの掲示板システムを運営していましたが、そこでは人々がログオンしてお互いにメッセージを残すことができ、プライベートなもの（電子メールに相当するもの）とパブリックなもの（ディスカッショングループ）がありました。同じ頃、CompuServeというオンラインサービスの存在も知りました。CompuServeの優れた機能の一つに「CB Simulator」というものがあり、人々がリアルタイムで会話をすることができました。すべてテキストベースでしたが、本物のCBラジオのように「チャンネル」という概念があり、同じチャンネルにいる限り、複数の人が他の人の入力した内容を見ることができました。 私は、タイムシェアリングシステム上で動作する自作のCBを作り、そのシステム上のユーザーがリアルタイムにメッセージを送れるようにしました。実は、そのうちの1つのシステムは今でも稼働していて、30数年前に大学で一緒だった人たちと毎日のように会話をしているんですよ。
しかし、スタンフォード大学でIPマルチキャストについて学んだとき、マルチキャストを使って真の「ラジオ」のようなものを手に入れることができるという考えに興味を持ちました。偶然にも、私がIPマルチキャストのコードを移植していたコンピュータは、サンの第一世代のSPARCステーションで、実は電話品質のオーディオハードウェアを内蔵していたのです。 マイクからの音をデジタル化して、内蔵スピーカー（またはヘッドフォン出力）で再生できるのです。そこで私が最初に考えたのは、IPマルチキャストを使ってその音声をリアルタイムでネットワーク上に送る方法を見つけ出し、テキストの代わりに実際の音声を使って「CBラジオ」に相当するものを作れないかということでした。</description></item><item><title>FAQ</title><link>https://webrtcforthecurious.com/ja/docs/11-faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ja/docs/11-faq/</guid><description>FAQ # なぜWebRTCはUDPを使うのですか？ NATトラバーサルにはUDPが必要です。NATトラバーサルがなければ、P2P接続の確立をすることはできません。 UDPはTCPのような「配信保証」を提供していないので、WebRTCではユーザーレベルで提供しています。
詳しくは 接続 をご覧ください
データチャンネルはいくつまで持てますか？ ストリームの識別子が16ビットなので、65536チャンネルです。いつでも新しいものを閉じたり開いたりできます。 WebRTCは帯域幅の制限がありますか？ DataChannels と RTP は共に輻輳制御を使用します。これは、WebRTC が帯域幅を積極的に測定し、最適な量を使用しようとすることを意味します。これは、接続を圧迫することなく、可能な限り多くのデータを送信するためのバランスです。 バイナリデータの送信は可能ですか？ はい、DataChannelsでは、テキストとバイナリの両方のデータを送信できます。 WebRTCのレイテンシーはどのくらいですか？ チューニングされていないメディアでは、500ミリ秒以下が期待できます。もし、レイテンシーのために品質を犠牲にしても構わないのであれば、開発者は100ミリ秒以下を実現しています。
DataChannelsは、&amp;ldquo;Partial-reliability &amp;ldquo;オプションをサポートしています。適切に設定されていれば、TCP TLS 接続よりも優れていることが示されています。
なぜDataChannelsに順序付けされていない配信が必要なのでしょうか？ 物体の位置情報など、新しい情報が古い情報を駆逐する場合や、各メッセージが他のメッセージから独立しており、回線の先頭でのブロック遅延を回避する必要がある場合などです。 DataChannelでオーディオやビデオを送信できますか？ どんなデータでもDataChannelで送ることができます。ブラウザの場合、データをデコードしてメディアプレーヤーに渡してレンダリングするのはあなたの責任ですが、メディアチャンネルを使用する場合は自動的に行われます。</description></item></channel></rss>