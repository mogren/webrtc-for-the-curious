<!doctype html><html lang=ja dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="WebRTCとは？ #  WebRTCとは、Web Real-Time Communicationの略で、APIであると同時にプロトコルでもあります。WebRTCプロトコルは、2つのWebRTCエージェントが双方向の安全なリアルタイム通信をネゴシエートするための一連のルールです。WebRTC APIは、開発者がWebRTCプロトコルを使用するためのものです。WebRTC APIは、JavaScriptのみで規定されています。
似たような関係として、HTTPとfetch APIがあります。プロトコルのWebRTCがHTTPで、APIのWebRTCがfetch APIとなります。
WebRTCプロトコルは、JavaScript以外のAPI/言語でも利用可能です。また、WebRTC用のサーバーやドメイン固有のツールもあります。これらの実装はすべて WebRTC プロトコルを使用しており、相互にやりとりできます。
WebRTCプロトコルは、IETFのrtcwebというワーキンググループで管理されています。WebRTC APIは、W3Cのwebrtc-pcで文書化されています。
なぜWebRTCを学ぶ必要があるのか？ #  WebRTC を使うことで得られるものは以下の通りです。このリストはすべてを網羅しているわけではありませんが、あなたが旅をしている間に感謝することもあるでしょう。これらの用語のいくつかをまだ知らなくても、この本が教えてくれますのでご安心ください。
 オープンスタンダード 複数の実装 ブラウザで利用可能 必須の暗号化 NATトラバーサル 既存技術の再利用 輻輳（ふくそう）制御 サブセカンドレイテンシー  WebRTCプロトコルは他の技術の集合体である #  これは、本1冊分の説明が必要なテーマです。しかし、ここでは4つのステップに分けて説明します。
 シグナリング 接続 セキュリティの確保 通信  この4つのステップは順番に行われます。前のステップが100％成功しなければ、次のステップは始まりません。
WebRTCの奇妙な点は、各ステップが実際には他の多くのプロトコルで構成されていることです。WebRTCを作るためには、多くの既存技術をつなぎ合わせます。その意味では、WebRTCは2000年代初頭から存在する、よく理解された技術を組み合わせて構成したものと言えます。
これらのステップはそれぞれ専用の章を設けていますが、まずは大まかに理解しておくと便利です。これらの手順はお互いに依存しているため、それぞれの手順の目的をさらに説明する際に役立ちます。
シグナリング: WebRTCでピアがお互いを見つける方法 #  WebRTCエージェントが起動したとき、誰と何の通信をするのかがわかりません。この問題を解決するのがシグナリングです。シグナリングは、2つのWebRTCエージェントが通信を開始できるように、通話をブートストラップするために使用されます。
シグナリングは、既存のプロトコルであるSDP（Session Description Protocol）を使用します。SDPはプレーンテキストのプロトコルです。各SDPメッセージは、キー／バリューペアで構成され、「メディアセクション」のリストを含んでいます。2つのWebRTCエージェントが交換するSDPには、以下のような詳細が含まれています。
 エージェントが到達可能なIPおよびポート (候補) エージェントが送信したいオーディオおよびビデオトラックの数 各エージェントがサポートするオーディオおよびビデオコーデック 接続時に使用される値 (uFrag/uPwd) セキュリティ確保時に使用される値 (証明書のフィンガープリント)  シグナリングは通常「アウトオブバンド」で行われることに注意してください。つまり、アプリケーションは通常、WebRTC自体を使用してシグナリングメッセージを交換することはありません。メッセージの送信に適した任意のアーキテクチャを使用して、接続しているピア間で SDP を中継できます。また、多くのアプリケーションは、既存のインフラストラクチャ (REST エンドポイント、WebSocket 接続、または認証プロキシ) を使用して、適切なクライアント間で SDP を簡単に交換できるようにします。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="何を、なぜ、どのように"><meta property="og:description" content="WebRTCとは？ #  WebRTCとは、Web Real-Time Communicationの略で、APIであると同時にプロトコルでもあります。WebRTCプロトコルは、2つのWebRTCエージェントが双方向の安全なリアルタイム通信をネゴシエートするための一連のルールです。WebRTC APIは、開発者がWebRTCプロトコルを使用するためのものです。WebRTC APIは、JavaScriptのみで規定されています。
似たような関係として、HTTPとfetch APIがあります。プロトコルのWebRTCがHTTPで、APIのWebRTCがfetch APIとなります。
WebRTCプロトコルは、JavaScript以外のAPI/言語でも利用可能です。また、WebRTC用のサーバーやドメイン固有のツールもあります。これらの実装はすべて WebRTC プロトコルを使用しており、相互にやりとりできます。
WebRTCプロトコルは、IETFのrtcwebというワーキンググループで管理されています。WebRTC APIは、W3Cのwebrtc-pcで文書化されています。
なぜWebRTCを学ぶ必要があるのか？ #  WebRTC を使うことで得られるものは以下の通りです。このリストはすべてを網羅しているわけではありませんが、あなたが旅をしている間に感謝することもあるでしょう。これらの用語のいくつかをまだ知らなくても、この本が教えてくれますのでご安心ください。
 オープンスタンダード 複数の実装 ブラウザで利用可能 必須の暗号化 NATトラバーサル 既存技術の再利用 輻輳（ふくそう）制御 サブセカンドレイテンシー  WebRTCプロトコルは他の技術の集合体である #  これは、本1冊分の説明が必要なテーマです。しかし、ここでは4つのステップに分けて説明します。
 シグナリング 接続 セキュリティの確保 通信  この4つのステップは順番に行われます。前のステップが100％成功しなければ、次のステップは始まりません。
WebRTCの奇妙な点は、各ステップが実際には他の多くのプロトコルで構成されていることです。WebRTCを作るためには、多くの既存技術をつなぎ合わせます。その意味では、WebRTCは2000年代初頭から存在する、よく理解された技術を組み合わせて構成したものと言えます。
これらのステップはそれぞれ専用の章を設けていますが、まずは大まかに理解しておくと便利です。これらの手順はお互いに依存しているため、それぞれの手順の目的をさらに説明する際に役立ちます。
シグナリング: WebRTCでピアがお互いを見つける方法 #  WebRTCエージェントが起動したとき、誰と何の通信をするのかがわかりません。この問題を解決するのがシグナリングです。シグナリングは、2つのWebRTCエージェントが通信を開始できるように、通話をブートストラップするために使用されます。
シグナリングは、既存のプロトコルであるSDP（Session Description Protocol）を使用します。SDPはプレーンテキストのプロトコルです。各SDPメッセージは、キー／バリューペアで構成され、「メディアセクション」のリストを含んでいます。2つのWebRTCエージェントが交換するSDPには、以下のような詳細が含まれています。
 エージェントが到達可能なIPおよびポート (候補) エージェントが送信したいオーディオおよびビデオトラックの数 各エージェントがサポートするオーディオおよびビデオコーデック 接続時に使用される値 (uFrag/uPwd) セキュリティ確保時に使用される値 (証明書のフィンガープリント)  シグナリングは通常「アウトオブバンド」で行われることに注意してください。つまり、アプリケーションは通常、WebRTC自体を使用してシグナリングメッセージを交換することはありません。メッセージの送信に適した任意のアーキテクチャを使用して、接続しているピア間で SDP を中継できます。また、多くのアプリケーションは、既存のインフラストラクチャ (REST エンドポイント、WebSocket 接続、または認証プロキシ) を使用して、適切なクライアント間で SDP を簡単に交換できるようにします。"><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/"><meta property="article:modified_time" content="2021-04-12T14:27:44+09:00"><meta property="og:site_name" content="好奇心旺盛な人のためのWebRTC"><title>何を、なぜ、どのように | 好奇心旺盛な人のためのWebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/ja.search.min.c7640f9c55721b479b0a55b74ca026315f7afa49b4fc5460e7cc0d94111b6d02.js integrity="sha256-x2QPnFVyG0ebClW3TKAmMV96+km0/FRg58wNlBEbbQI="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/ja><span>好奇心旺盛な人のためのWebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ class=active>何を、なぜ、どのように</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/02-signaling/>シグナリング</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>接続</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>セキュリティ対策</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/05-real-time-networking/>リアルタイム・ネットワーキング</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/06-media-communication/>メディア・コミュニケーション</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>データ・コミュニケーション</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/08-applied-webrtc/>応用WebRTC</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/>デバッグ</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/10-history-of-webrtc/>歴史</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/11-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>何を、なぜ、どのように</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#なぜwebrtcを学ぶ必要があるのか>なぜWebRTCを学ぶ必要があるのか？</a></li><li><a href=#webrtcプロトコルは他の技術の集合体である>WebRTCプロトコルは他の技術の集合体である</a><ul><li><a href=#シグナリング-webrtcでピアがお互いを見つける方法>シグナリング: WebRTCでピアがお互いを見つける方法</a></li><li><a href=#stunturn-による接続と-nat-トラバーサル>STUN/TURN による接続と NAT トラバーサル</a></li><li><a href=#dtls-と-srtp-によるトランスポート層のセキュリティ確保>DTLS と SRTP によるトランスポート層のセキュリティ確保</a></li><li><a href=#rtp-および-sctp-によるピアとの通信>RTP および SCTP によるピアとの通信</a></li></ul></li><li><a href=#プロトコルの集合体であるwebrtc>プロトコルの集合体であるWebRTC</a></li><li><a href=#webrtc-api-はどのように動作するか>WebRTC (API) はどのように動作するか</a><ul><li></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=webrtcとは>WebRTCとは？
<a class=anchor href=#webrtc%e3%81%a8%e3%81%af>#</a></h1><p>WebRTCとは、Web Real-Time Communicationの略で、APIであると同時にプロトコルでもあります。WebRTCプロトコルは、2つのWebRTCエージェントが双方向の安全なリアルタイム通信をネゴシエートするための一連のルールです。WebRTC APIは、開発者がWebRTCプロトコルを使用するためのものです。WebRTC APIは、JavaScriptのみで規定されています。</p><p>似たような関係として、HTTPとfetch APIがあります。プロトコルのWebRTCがHTTPで、APIのWebRTCがfetch APIとなります。</p><p>WebRTCプロトコルは、JavaScript以外のAPI/言語でも利用可能です。また、WebRTC用のサーバーやドメイン固有のツールもあります。これらの実装はすべて WebRTC プロトコルを使用しており、相互にやりとりできます。</p><p>WebRTCプロトコルは、IETFの<a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a>というワーキンググループで管理されています。WebRTC APIは、W3Cの<a href=https://w3c.github.io/webrtc-pc/>webrtc-pc</a>で文書化されています。</p><h2 id=なぜwebrtcを学ぶ必要があるのか>なぜWebRTCを学ぶ必要があるのか？
<a class=anchor href=#%e3%81%aa%e3%81%9cwebrtc%e3%82%92%e5%ad%a6%e3%81%b6%e5%bf%85%e8%a6%81%e3%81%8c%e3%81%82%e3%82%8b%e3%81%ae%e3%81%8b>#</a></h2><p>WebRTC を使うことで得られるものは以下の通りです。このリストはすべてを網羅しているわけではありませんが、あなたが旅をしている間に感謝することもあるでしょう。これらの用語のいくつかをまだ知らなくても、この本が教えてくれますのでご安心ください。</p><ul><li>オープンスタンダード</li><li>複数の実装</li><li>ブラウザで利用可能</li><li>必須の暗号化</li><li>NATトラバーサル</li><li>既存技術の再利用</li><li>輻輳（ふくそう）制御</li><li>サブセカンドレイテンシー</li></ul><h2 id=webrtcプロトコルは他の技術の集合体である>WebRTCプロトコルは他の技術の集合体である
<a class=anchor href=#webrtc%e3%83%97%e3%83%ad%e3%83%88%e3%82%b3%e3%83%ab%e3%81%af%e4%bb%96%e3%81%ae%e6%8a%80%e8%a1%93%e3%81%ae%e9%9b%86%e5%90%88%e4%bd%93%e3%81%a7%e3%81%82%e3%82%8b>#</a></h2><p>これは、本1冊分の説明が必要なテーマです。しかし、ここでは4つのステップに分けて説明します。</p><ul><li>シグナリング</li><li>接続</li><li>セキュリティの確保</li><li>通信</li></ul><p>この4つのステップは順番に行われます。前のステップが100％成功しなければ、次のステップは始まりません。</p><p>WebRTCの奇妙な点は、各ステップが実際には他の多くのプロトコルで構成されていることです。WebRTCを作るためには、多くの既存技術をつなぎ合わせます。その意味では、WebRTCは2000年代初頭から存在する、よく理解された技術を組み合わせて構成したものと言えます。</p><p>これらのステップはそれぞれ専用の章を設けていますが、まずは大まかに理解しておくと便利です。これらの手順はお互いに依存しているため、それぞれの手順の目的をさらに説明する際に役立ちます。</p><h3 id=シグナリング-webrtcでピアがお互いを見つける方法>シグナリング: WebRTCでピアがお互いを見つける方法
<a class=anchor href=#%e3%82%b7%e3%82%b0%e3%83%8a%e3%83%aa%e3%83%b3%e3%82%b0-webrtc%e3%81%a7%e3%83%94%e3%82%a2%e3%81%8c%e3%81%8a%e4%ba%92%e3%81%84%e3%82%92%e8%a6%8b%e3%81%a4%e3%81%91%e3%82%8b%e6%96%b9%e6%b3%95>#</a></h3><p>WebRTCエージェントが起動したとき、誰と何の通信をするのかがわかりません。この問題を解決するのがシグナリングです。シグナリングは、2つのWebRTCエージェントが通信を開始できるように、通話をブートストラップするために使用されます。</p><p>シグナリングは、既存のプロトコルであるSDP（Session Description Protocol）を使用します。SDPはプレーンテキストのプロトコルです。各SDPメッセージは、キー／バリューペアで構成され、「メディアセクション」のリストを含んでいます。2つのWebRTCエージェントが交換するSDPには、以下のような詳細が含まれています。</p><ul><li>エージェントが到達可能なIPおよびポート (候補)</li><li>エージェントが送信したいオーディオおよびビデオトラックの数</li><li>各エージェントがサポートするオーディオおよびビデオコーデック</li><li>接続時に使用される値 (uFrag/uPwd)</li><li>セキュリティ確保時に使用される値 (証明書のフィンガープリント)</li></ul><p>シグナリングは通常「アウトオブバンド」で行われることに注意してください。つまり、アプリケーションは通常、WebRTC自体を使用してシグナリングメッセージを交換することはありません。メッセージの送信に適した任意のアーキテクチャを使用して、接続しているピア間で SDP を中継できます。また、多くのアプリケーションは、既存のインフラストラクチャ (REST エンドポイント、WebSocket 接続、または認証プロキシ) を使用して、適切なクライアント間で SDP を簡単に交換できるようにします。</p><h3 id=stunturn-による接続と-nat-トラバーサル>STUN/TURN による接続と NAT トラバーサル
<a class=anchor href=#stunturn-%e3%81%ab%e3%82%88%e3%82%8b%e6%8e%a5%e7%b6%9a%e3%81%a8-nat-%e3%83%88%e3%83%a9%e3%83%90%e3%83%bc%e3%82%b5%e3%83%ab>#</a></h3><p>これで、2 つの WebRTC Agent は、お互いに接続を試みるのに十分な詳細を知ることができました。WebRTC は ICE という別の確立された技術を使用します。</p><p>ICE（Interactive Connectivity Establishment）は、WebRTC よりも前のプロトコルです。ICEでは、2つのAgent間で接続を確立できます。これらのAgentは、同じネットワーク上にある場合もあれば、地球の反対側にある場合もあります。ICEは、中央のサーバーを使わずに直接接続を確立するためのソリューションです。</p><p>ここでの本当の魔法は、「NATトラバーサル」と「STUN/TURNサーバー」です。この2つの概念があれば、別のサブネットにいるICEエージェントと通信できます。これらのトピックについては、後ほど詳しく説明します。</p><p>ICE が接続に成功すると、WebRTC は暗号化トランスポートの確立に進みます。このトランスポートは、音声、ビデオ、データに使用されます。</p><h3 id=dtls-と-srtp-によるトランスポート層のセキュリティ確保>DTLS と SRTP によるトランスポート層のセキュリティ確保
<a class=anchor href=#dtls-%e3%81%a8-srtp-%e3%81%ab%e3%82%88%e3%82%8b%e3%83%88%e3%83%a9%e3%83%b3%e3%82%b9%e3%83%9d%e3%83%bc%e3%83%88%e5%b1%a4%e3%81%ae%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e7%a2%ba%e4%bf%9d>#</a></h3><p>ICE による双方向通信が可能になったところで、安全な通信を確立する必要があります。これには、WebRTC よりも古い 2 つのプロトコルを使用します。1つ目のプロトコルはDTLS（Datagram Transport Layer Security）で、これはUDP上のTLSに過ぎません。TLSは、HTTPSでの通信を保護するために使用される暗号化プロトコルです。2つ目のプロトコルはSRTP（Secure Real-time Transport Protocol）です。</p><p>まず、WebRTCはICEで確立された接続の上でDTLSハンドシェイクを行って接続します。HTTPS とは異なり、WebRTC は証明書に中央機関を使用しません。代わりに、WebRTC は、DTLS を通じて交換された証明書が、シグナリングによって共有されたフィンガープリントと一致することを表明します。このDTLS接続は、DataChannelメッセージに使用されます。</p><p>WebRTCは、RTPと呼ばれるオーディオ／ビデオ伝送用の別のプロトコルを使用します。RTP パケットのセキュリティには SRTP を使用します。SRTP セッションは、ネゴシエートされた DTLS セッションからキーを抽出して初期化します。後の章では、メディア伝送に独自のプロトコルが必要な理由について説明します。</p><p>これで完了です。これで、双方向の安全な通信が可能になりました。WebRTC エージェント間の接続が安定していれば、これだけで複雑な作業は必要ありません。残念ながら、現実の世界ではパケットロスや帯域幅の制限があり、次のセクションではそれらに対処する方法を説明します。</p><h3 id=rtp-および-sctp-によるピアとの通信>RTP および SCTP によるピアとの通信
<a class=anchor href=#rtp-%e3%81%8a%e3%82%88%e3%81%b3-sctp-%e3%81%ab%e3%82%88%e3%82%8b%e3%83%94%e3%82%a2%e3%81%a8%e3%81%ae%e9%80%9a%e4%bf%a1>#</a></h3><p>これで2つのWebRTC Agentが安全な双方向通信を行うことができました。それでは早速、通信を開始しましょう。ここでも、既存の 2 つのプロトコルを使用します。RTP（Real-time Transport Protocol）とSCTP（Stream Control Transmission Protocol）です。RTPでやり取りされるメディアの暗号化にはSRTPを、DTLSで暗号化されたDataChannelメッセージの送信にはSCTPを使用します。</p><p>RTPは最小限の機能しか備えていませんが、リアルタイムストリーミングを実現するために必要な機能を備えています。重要なのは、RTPが開発者に柔軟性を与えていることで、開発者はレイテンシー、ロス、輻輳を思い通りに処理できます。この点については、「メディア」の章で詳しく説明します。</p><p>スタックの最後のプロトコルはSCTPです。SCTPでは、メッセージの配信オプションが多数用意されています。オプションで、信頼性のない、順番のない配信を選択できますので、リアルタイムシステムに必要なレイテンシーを得ることができます。</p><h2 id=プロトコルの集合体であるwebrtc>プロトコルの集合体であるWebRTC
<a class=anchor href=#%e3%83%97%e3%83%ad%e3%83%88%e3%82%b3%e3%83%ab%e3%81%ae%e9%9b%86%e5%90%88%e4%bd%93%e3%81%a7%e3%81%82%e3%82%8bwebrtc>#</a></h2><p>WebRTCは多くの問題を解決します。最初は、過剰な技術とさえ思えるかもしれません。WebRTCの天才的なところは、実に謙虚なところです。WebRTCは、自分たちがすべてをうまく解決できるとは考えませんでした。その代わりに、多くの既存の単一目的の技術を採用し、それらを束ねました。</p><p>これにより、私たちは圧倒されることなく、各部分を個別に検討し、学ぶことができるのです。WebRTCエージェント」とは、実際には多くの異なるプロトコルのオーケストレーターに過ぎないことを視覚化するのに良い方法です。</p><p><img src=/images/01-webrtc-agent.png alt="WebRTC Agent" title="WebRTC Agent Diagram"></p><h2 id=webrtc-api-はどのように動作するか>WebRTC (API) はどのように動作するか
<a class=anchor href=#webrtc-api-%e3%81%af%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%ab%e5%8b%95%e4%bd%9c%e3%81%99%e3%82%8b%e3%81%8b>#</a></h2><p>このセクションでは、JavaScript の API がプロトコルにどのように対応するかを示します。これは、WebRTC API の広範なデモを意味するものではなく、すべてがどのように結びついているかのメンタルモデルを作成するためのものです。
どちらにも慣れていない方でも問題ありません。このセクションは、より多くのことを学ぶために戻ってくる楽しみがあるかもしれません。</p><h4 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h4><p><code>RTCPeerConnection</code> は、トップレベルの「WebRTCセッション」です。これには上述のすべてのプロトコルが含まれています。サブシステムはすべて割り当てられていますが、まだ何も起こりません。</p><h4 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h4><p><code>addTrack</code> は新しい RTP ストリームを作成します。このストリームには、ランダムな同期ソース (SSRC) が生成されます。このストリームは、メディアセクション内の <code>createOffer</code> で生成されたセッション記述の中に入ります。 <code>addTrack</code> を呼び出すたびに、新しいSSRCとメディアセクションが作成されます。</p><p>SRTPセッションが確立されるとすぐに、これらのメディアパケットはSRTPで暗号化された後、ICE経由で送信され始めます。</p><h4 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h4><p><code>createDataChannel</code> は、SCTPアソシエーションが存在しない場合に、新しいSCTPストリームを作成します。デフォルトでは、SCTPは有効ではなく、一方の側がデータチャネルを要求したときにのみ開始されます。</p><p>DTLSセッションが確立された直後に、SCTPアソシエーションはICEを経由してDTLSで暗号化されたパケットの送信を開始します。</p><h4 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h4><p><code>createOffer</code> は、リモートピアと共有するローカルステートのSession Descriptionを生成します。</p><p><code>createOffer</code> を呼び出しても、ローカルピアは何も変わりません。</p><h4 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h4><p><code>setLocalDescription</code> は要求されたすべての変更をコミットします。<code>addTrack</code>, <code>createDataChannel</code> などの呼び出しは、この呼び出しまではすべて一時的なものです。 <code>setLocalDescription</code> は <code>createOffer</code> で生成された値で呼び出されます。</p><p>通常、この呼び出しの後、リモートピアにオファーを送信し、リモートピアはそれを使って <code>setRemoteDescription</code> を呼び出します。</p><h4 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h4><p><code>setRemoteDescription</code> は、リモート候補の状態をローカルエージェントに通知する方法です。これは、JavaScriptのAPIで「シグナリング」という行為を行う方法です。</p><p>双方で <code>setRemoteDescription</code> が呼び出されると、WebRTCエージェントはP2P通信を開始するのに十分な情報を得ることができます!</p><h4 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h4><p><code>addIceCandidate</code> を使うと、WebRTCエージェントはいつでも好きなときにリモートのICE候補を追加できます。この API は ICE サブシステムに ICE Candidate を直接送信し、大規模な WebRTC 接続には他の影響を与えません。</p><h4 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h4><p><code>ontrack</code> は、リモートピアからRTPパケットを受信したときに起動されるコールバックです。受信パケットは、<code>setRemoteDescription</code> に渡されたセッション記述で宣言されているはずです。</p><p>WebRTC は SSRC を使用して、関連する <code>MediaStream</code> と <code>MediaStreamTrack</code> を検索し、これらの詳細が入力された状態でこのコールバックを起動します。</p><h4 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h4><p><code>oniceconnectionstatechange</code> は、ICEエージェントの状態を反映して起動されるコールバックです。ネットワークに接続されたときや、切断されたときに、このように通知されます。</p><h4 id=onstatechange><code>onstatechange</code>
<a class=anchor href=#onstatechange>#</a></h4><p><code>onstatechange</code> は、ICEエージェントとDTLSエージェントの状態を組み合わせたものです。これを見ることで、ICEとDTLSの両方が正常に完了したときに通知を受けることができます。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li><li><a href=https://webrtcforthecurious.com/fa/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li class=active><a href=https://webrtcforthecurious.com/ja/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/aef88af93e0568a6b7af681453eb2e8dffa7147c title="最終更新者 Yuto AOKI | April 12, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 12, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.ja/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>このページを編集する</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#なぜwebrtcを学ぶ必要があるのか>なぜWebRTCを学ぶ必要があるのか？</a></li><li><a href=#webrtcプロトコルは他の技術の集合体である>WebRTCプロトコルは他の技術の集合体である</a><ul><li><a href=#シグナリング-webrtcでピアがお互いを見つける方法>シグナリング: WebRTCでピアがお互いを見つける方法</a></li><li><a href=#stunturn-による接続と-nat-トラバーサル>STUN/TURN による接続と NAT トラバーサル</a></li><li><a href=#dtls-と-srtp-によるトランスポート層のセキュリティ確保>DTLS と SRTP によるトランスポート層のセキュリティ確保</a></li><li><a href=#rtp-および-sctp-によるピアとの通信>RTP および SCTP によるピアとの通信</a></li></ul></li><li><a href=#プロトコルの集合体であるwebrtc>プロトコルの集合体であるWebRTC</a></li><li><a href=#webrtc-api-はどのように動作するか>WebRTC (API) はどのように動作するか</a><ul><li></li></ul></li></ul></nav></div></aside></main></body></html>