'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/sv/docs/01-what-why-and-how/','title':"Vad, varför och hur",'section':"Docs",'content':"Vad är WebRTC? #  WebRTC, förkortning för Web Real-Time Communication, är både ett API och ett protokoll. WebRTC-protokollet är en uppsättning regler som två WebRTC-agenter använder för att sätta upp en säker tvåvägs realtidskommunikation. WebRTC API:et tillåter sedan utvecklare att använda WebRTC-protokollet. WebRTC API:et är endast specificerat för JavaScript.\nEtt liknande förhållande skulle vara det mellan HTTP och Fetch API:et. WebRTC protokollet skulle vara HTTP, och WebRTC API:et motsvarar Fetch API:et.\nWebRTC-protokollet finns tillgängligt i andra API:er och språk än JavaScript. Du kan också hitta servrar och domänspecifika verktyg för WebRTC. Alla dessa implementationer använder WebRTC-protokollet så att de kan kommunicera med varandra.\nWebRTC-protokollet upprätthålls i IETF i arbetsgruppen rtcweb. WebRTC API:et är dokumenterat i W3C som webrtc-pc.\nVarför ska jag lära mig WebRTC? #  Det här är en lista på några saker som WebRTC kommer att ge dig. Listan är inte komplett, bara exempel på saker. Oroa dig inte om du inte känner till alla dessa termer ännu, den här boken kommer att lära dig dem på vägen.\n Öppen standard Flera implementeringar Fungerar direkt i webbläsare Obligatorisk kryptering NAT Traversal Byggt på beprövad, befintlig, teknik Trängselkontroll Sub-sekunders latens  WebRTC Protokollet är en samling av andra tekniker #  Detta är ett ämne som kan ta en hel bok att förklara, men till att börja med delar vi upp det i fyra steg.\n Signalering Anslutning Säkerhet Kommunikation  Dessa fyra steg sker alltid i den här ordningen. Varje steg måste vara helt klart utan problem för att det efterföljande steget ska kunna börja.\nEn intressant sak med WebRTC är att varje steg faktiskt består av många andra protokoll och befintliga tekniker. I den meningen är WebRTC egentligen bara en kombination av beprövad teknik som har funnits sedan början av 2000-talet.\nVi kommer att gå igenom alla dessa steg i detalj senare, men det är bra att först förstå dem på en hög nivå. Eftersom de är beroende av varandra kommer det att hjälpa dig när vi senare förklarar syftet med vart och ett av dessa steg.\nSignalering: Hur parter hittar varandra i WebRTC #  När en WebRTC-agent startar har den ingen aning om vem den ska kommunicera med och vad de ska kommunicera om. Signalering löser problemet! Signalering används för att starta samtalet så att två WebRTC-agenter kan börja kommunicera.\nSignalering använder ett befintligt protokoll SDP (Session Description Protocol). SDP är ett enkelt textbaserat protokoll. Varje SDP-meddelande består av nyckel/värdepar och innehåller en lista med \u0026ldquo;media sections\u0026rdquo;. SDP:n som de två WebRTC agenterna utbyter innehåller detaljer som:\n IP-adresser och portar som agenten kan nås på (kandidater). Hur många ljud- och videospår agenten vill skicka. Vilka ljud- och video-kodek som varje agent stöder. Värden som används vid anslutning (uFrag/uPwd). Värden som används vid säkringen (certifikatfingeravtryck).  Observera att signalering vanligtvis sker \u0026ldquo;utanför bandet\u0026rdquo;; applikationer använder i allmänhet inte WebRTC för att handla signalmeddelanden. Vilken arkitektur som helst som är lämplig för att skicka meddelanden kan användas för att vidarebefordra SDP:erna mellan de anslutande parterna. Många applikationer använder sin befintliga infrastruktur (som REST-API:er, WebSocket-anslutningar eller autentiserande proxys) för att på enklaste sätt utbyta SDP:er mellan rätt klienter.\nAnslutning och NAT Traversal med STUN/TURN #  De två WebRTC-agenterna vet nu tillräckligt med detaljer för att försöka ansluta till varandra. WebRTC använder sedan en annan etablerad teknik som kallas ICE.\nICE (Interactive Connectivity Establishment) är ett protokoll som skapades före WebRTC. ICE används för att upprätt av en anslutning mellan två agenter. Dessa agenter kan vara i samma nätverk eller på andra sidan världen. ICE är används för att skapa en direktanslutning utan att gå via en central server.\nDen verkliga magin här är \u0026ldquo;NAT Traversal\u0026rdquo; och STUN/TURN-servrar. Dessa två begrepp är allt du behöver för att kommunicera med en ICE-agent i ett annat sub-nät. Vi kommer att utforska dessa ämnen djupare senare.\nNär ICE väl har anslutits går WebRTC vidare till att upprätta en krypterad transport. Denna kommunikationskanal används för ljud, video och data.\nSäkra transportskiktet med DTLS och SRTP #  Nu när vi har dubbelriktad kommunikation (via ICE) måste vi sätta upp en säker kommunikationskanal. Detta görs genom två protokoll som också är äldre än WebRTC. Det första protokollet är DTLS (Datagram Transport Layer Security) som helt enkelt är TLS över UDP. TLS är det kryptografiska protokollet som används för att säkra kommunikation via HTTPS. Det andra protokollet är SRTP (Secure Real-time Transport Protocol).\nFörst ansluter WebRTC genom att göra en DTLS-handskakning över anslutningen som upprättats av ICE. Till skillnad från HTTPS använder WebRTC inte en vanlig CA (Certificate Authority) för certifikatet. Istället hävdar WebRTC bara att certifikatet som utbyts via DTLS matchar. Denna DTLS-anslutning används sedan för DataChannel-meddelanden.\nWebRTC använder sedan ett annat protokoll för ljud- och video-överföring som heter RTP. Vi skyddar våra RTP-paket med SRTP. Vi initierar vår SRTP-session genom att extrahera nycklarna från den förhandlade DTLS-sessionen. Vi kommer att gå igenom varför medieöverföring har ett eget protokoll i ett senare kapitel.\nNu är vi klara! Du har nu dubbelriktad och säker kommunikation. Om du har en stabil anslutning mellan dina WebRTC-agenter är det här all komplexitet du behöver. Tyvärr har den verkliga världen andra problem som paketförlust och brist på bandbredd. Nästa avsnitt handlar om hur vi hanterar dem.\nKommunicera med parter via RTP och SCTP #  Vi har nu två WebRTC-agenter med säker dubbelriktad kommunikation. Låt oss börja kommunicera! Återigen använder vi två befintliga protokoll: RTP (Real-time Transport Protocol) och SCTP (Stream Control Transmission Protocol). Använd RTP för att utbyta media krypterat med SRTP och använd SCTP för att skicka och ta emot DataChannel-meddelanden krypterade med DTLS.\nRTP är ganska minimalt, men ger oss allt vi behöver för att implementera realtidsströmning. Det viktiga är att RTP ger utvecklaren flexibilitet, så att de kan hantera latens, förlust och trängsel som de vill. Vi kommer att gå igenom detta ytterligare i mediekapitlet.\nDet slutliga protokollet i stacken är SCTP. SCTP tillåter många leveransalternativ för meddelanden. Du kan till exempel välja att ha opålitlig leverans utan ordning, så att du kan få den latens som behövs för realtidssystem.\nWebRTC, en samling protokoll #  WebRTC löser väldigt många problem åt oss. Först kan detta verka väldigt ambitiöst, men det smarta med WebRTCs är att man inte försökte lösa allt själva. Istället återanvände man många befintliga tekniker för enskilda ändamål och kombinerade dem.\nDetta gör att vi kan undersöka och lära oss om varje del individuellt, utan att bli överväldigade. Ett bra sätt att visualisera det hela är att en \u0026ldquo;WebRTC Agent\u0026rdquo; egentligen bara är en samordnare av många olika protokoll.\nHur fungerar API:et WebRTC #  Det här avsnittet visar hur JavaScript API:et kopplas till protokollet. Detta är inte tänkt som ett omfattande demo av WebRTC API:et, utan mer för att skapa en mental modell för hur det hela hänger ihop. Om du inte känner till någon av dem är det ok. Det här kan vara ett roligt avsnitt att återvända till när du lär dig mer!\nnew RTCPeerConnection #  RTCPeerConnection är den högsta nivån av en \u0026ldquo;WebRTC Session\u0026rdquo;. Den innehåller alla ovan nämnda protokoll. Delsystemen är alla allokerade men ingenting händer ännu.\naddTrack #  addTrack skapar en ny RTP-ström. En slumpmässig synkroniseringskälla (SSRC) kommer att genereras för denna ström. Den här strömmen kommer sedan att finnas i Sessionsbeskrivningen som genereras av createOffer inuti en media-sektion. Varje samtal till addTrack skapar en ny SSRC och media-sektion.\nOmedelbart efter att en SRTP-session har upprättats kommer dessa mediepaket att skickas via ICE efter att ha krypterats med SRTP.\ncreateDataChannel #  createDataChannel skapar en ny SCTP-ström om det inte finns någon SCTP-koppling. Som standard är SCTP inte aktiverat men startas bara när en sida begär en datakanal.\nOmedelbart efter att en DTLS-session har upprättats kommer SCTP-föreningen att skicka paket via ICE och krypteras med DTLS.\ncreateOffer #  createOffer genererar en sessionsbeskrivning (Session Description) av det lokala tillståndet som ska delas med den andra parten.\nHandlingen att anropa createOffer förändrar ingenting för den lokala parten.\nsetLocalDescription #  setLocalDescription gör alla begärda ändringar. addTrack, createDataChannel och liknande anrop är alla tillfälliga tills detta anrop görs. setLocalDescription anropas med det värde som genereras av createOffer.\nVanligtvis, efter det här anropet, kommer du att skicka erbjudandet till den andra parten, och de kommer att kalla setRemoteDescription med den.\nsetRemoteDescription #  setRemoteDescription är hur vi informerar den lokala agenten om andra kandidaters tillstånd. Så här görs signalering med JavaScript API:et.\nNär setRemoteDescription har anropats på båda sidor har WebRTC Agenterna nu tillräckligt med information för att börja kommunicera direkt part-till-part (P2P)!\naddIceCandidate #  addIceCandidate tillåter en WebRTC-agent att lägga till fler ICE-kandidater på avstånd när de vill. Detta API skickar ICE-kandidaten direkt in i ICE-delsystemet och har ingen annan effekt på den större WebRTC-anslutningen.\nontrack #  ontrack är ett återanrop som avfyras när ett RTP-paket tas emot från den andra parten. De inkommande paketen skulle ha deklarerats i Sessionsbeskrivningen som skickades till setRemoteDescription.\nWebRTC använder SSRC för att hitta rätt MediaStream och MediaStreamTrack, och avfyrar återanropet med dessa detaljer fyllda.\noniceconnectionstatechange #  oniceconnectionstatechange är en återanrop som avfyras för att visa tillståndet hos ICE-agenten. När du har fått en nätverksanslutning eller när du kopplas bort så får du det här meddelandet.\nonstatechange #  onstatechange är en kombination av ICE Agenten och DTLS Agentens tillstånd. Du kan lyssna på detta meddelande för att få veta när uppsättningen av både ICE och DTLS har slutförts.\n"});index.add({'id':1,'href':'/sv/docs/02-signaling/','title':"Signalering",'section':"Docs",'content':"Vad är WebRTC-signalering? #  När du skapar en WebRTC-agent vet den ingenting om den andra parten. Den har ingen aning om vem den kommer att ansluta till eller vad för data de ska skicka! Signalering är den första konfigureringen som gör ett samtal möjligt. Efter att dessa värden har utbytts kan WebRTC-agenterna kommunicera direkt med varandra.\nSignalmeddelanden är bara vanlig text och WebRTC-agenterna bryr sig inte hur de skickas. De utbyts vanligtvis via Websockets, men det är inte ett krav.\nHur fungerar WebRTC-signalering? #  WebRTC använder ett befintligt protokoll som kallas Session Description Protocol. Via detta protokoll delar de två WebRTC-agenterna alla tillstånd som krävs för att upprätta en anslutning. Protokollet i sig är enkelt att läsa och förstå. Komplexiteten kommer när man försöker förstå alla värden som WebRTC fyller i åt dig.\nSDP protokollet är inte skapat specifikt för WebRTC. Eftersom WebRTC bara utnyttjar en liten del av protokollet ska vi bara gå igenom det vi behöver. När vi förstår protokollet kommer vi att gå vidare till hur det används i WebRTC.\nVad är Session Description Protocol (SDP)? #  Sessionsbeskrivningsprotokollet definieras i RFC 4566. Det är ett nyckel/värde-protokoll med en ny rad efter varje värde, ungefär som en INI-fil. En sessionsbeskrivning (Session Description) innehåller noll eller fler mediebeskrivningar (Media Descriptions). Mentalt kan du se det som att en sessionsbeskrivning innehåller en uppsättning mediebeskrivningar.\nEn mediebeskrivning beskriver vanligtvis en enda ström av media. Så om du ville beskriva ett samtal med tre videoströmmar och två ljudspår skulle du ha fem mediebeskrivningar.\nHur man läser SDP #  Varje rad i en sessionsbeskrivning börjar med ett enda tecken, det här är din nyckel. Det kommer sedan att följas av ett likhetstecken. Allt efter det lika tecknet är värdet. När värdet är klart kommer du att ha en ny rad.\nSession Description Protocol definierar alla nycklar som är giltiga. Du kan bara använda bokstäver för nycklar enligt definitionen i protokollet. Dessa tangenter har alla betydande betydelse, vilket kommer att förklaras senare.\nHär är ett exempel på en del av en sessionsbeskrivning:\na=my-sdp-value a=second-value Du har två rader. Var och en med nyckeln a. Den första raden har värdet my-sdp-value, den andra raden har värdet second-value.\nWebRTC använder bara vissa SDP-nycklar #  Inte alla nycklar som definieras i SDP används av WebRTC. Följande sju nycklar är de enda du behöver förstå just nu:\n v - Version, ska vara satt till 0. o - Ursprung (Origin). Innehåller ett unikt ID som är användbart för omförhandlingar. s - Sessionsnamn, ska vara satt till -. t - Timing, ska vara satt till 0 0. m - Mediebeskrivning (m=\u0026lt;media\u0026gt; \u0026lt;port\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;fmt\u0026gt; ... ), beskriven i detalj nedan. a - Attribut, ett fritextfält. Detta är den vanligaste raden i WebRTC. c - Anslutningsdata bör vara satt till IN IP4 0.0.0.0.  Mediebeskrivningar i en sessionsbeskrivning #  En sessionsbeskrivning kan innehålla ett obegränsat antal mediebeskrivningar.\nVarje mediabeskrivning kan innehålla en lista med olika format. Dessa format kopplas till RTP Payload Types. Den faktiska kodeken definieras sedan av ett attribut med värdet rtpmap i mediabeskrivningen. Vikten av RTP och RTP Payload Types diskuteras senare i kapitlet om Media. Varje mediebeskrivning kan innehålla ett obegränsat antal attribut.\nTa den här delen av en sessionsbeskrivning som ett exempel:\nv=0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4000 RTP/AVP 96 a=rtpmap:96 VP8/90000 a=my-sdp-value Du har två medibeskrivningar, en av typ av ljud med FMT 111 och en av typ av video med formatet 96. Den första mediebeskrivningen har bara ett attribut. Detta attribut specificerar att Payload Type är 111 för Opus. Den andra mediebeskrivningen har två attribut. Det första attributet specificerar Payload Type är 96 för VP8, och det andra attributet är helt enkelt bara my-sdp-value.\nEtt komplett exempel #  Följande exempel innehåller alla begrepp som vi har pratat om. Det här är alla funktioner i SDP som WebRTC använder. Om du kan läsa och förstå detta, kan du läsa vilken WebRTC-session som helst!\nv=0 o=- 0 0 IN IP4 127.0.0.1 s=- c=IN IP4 127.0.0.1 t=0 0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4002 RTP/AVP 96 a=rtpmap:96 VP8/90000  v, o, s, c, t är definierade, men de påverkar inte WebRTC-sessionen. Du har två mediebeskrivningar. En av typen audio (ljud) och en av typen video. Var och en av dessa har ett attribut. Detta attribut konfigurerar detaljer om RTP-pipelinen, vilket diskuteras i kapitlet \u0026ldquo;Mediekommunikation\u0026rdquo;.  Hur Session Description Protocol och WebRTC fungerar tillsammans #  Nästa pusselbit är att förstå hur WebRTC använder Session Description protokollet.\nVad är erbjudanden och svar? #  WebRTC använder en erbjudande/svar-modell. Det betyder att den ena WebRTC-agenten gör ett \u0026ldquo;erbjudande\u0026rdquo; (\u0026ldquo;Offer\u0026rdquo;) för att starta ett samtal, och den andra WebRTC-agenten ger ett \u0026ldquo;svar\u0026rdquo; (\u0026ldquo;Answer\u0026rdquo;) om den är villig att acceptera det som erbjudits.\nDetta ger svararen en chans att säga nej till kodeks i media-beskrivningarna (Media Descriptions). Det här är sättet två parter kommer överens om vilka format de är villiga att utbyta.\nTransceivers är avsedda för sändning och mottagning #  Transceivers är ett WebRTC-specifikt koncept som du kommer att se i API:et. Vad den gör är att exponera \u0026ldquo;Media Description\u0026rdquo; för JavaScript API. Varje mediebeskrivning blir en sändtagare. Varje gång du skapar en Transceiver läggs en ny mediebeskrivning till den lokala sessionsbeskrivningen.\nVarje mediebeskrivning i WebRTC har ett riktningsattribut (direction attribute). Detta gör det möjligt för en WebRTC-agent att förklara \u0026ldquo;Jag ska skicka dig denna codec, men jag är inte villig att acceptera något tillbaka\u0026rdquo;. Det finns fyra giltiga värden:\n send recv sendrecv inactive  SDP-värden som används av WebRTC #  Nedan är en lista över några vanliga attribut som du kommer att se i en sessionsbeskrivning från en WebRTC-agent. Många av dessa värden styr delsystem som vi ännu inte har diskuterat.\ngrupp:BUNDLE #  Bundling är när man kör flera typer av trafik över en och samma anslutning. Vissa WebRTC-implementeringar använder en dedikerad anslutning per mediaström. Buntning är att föredra.\nfingerprint:sha-256 #  Detta är en hash av certifikatet som en part använder för DTLS. När DTLS-handskakningen är klar jämför du detta med det faktiska certifikatet för att bekräfta att du kommunicerar med den du har förväntat dig.\nsetup: #  Detta kontrollerar beteendet för DTLS-agenten. Detta avgör om det körs som en klient eller server efter att ICE har anslutit. De möjliga värdena är:\n setup: active - Kör som DTLS-klient. setup: passive - Kör som DTLS-server. setup: actpass - Be den andra WebRTC-agenten att välja.  ice-ufrag #  Detta är användarfragmentvärdet för ICE-agenten. Används för verifiering av ICE trafik.\nice-pwd #  Detta är lösenordet för ICE-agenten. Används för autentisering av ICE trafik.\nrtpmap #  Detta värde används för att koppla en specifik kodek till en RTP Payload Type. Payload Types är inte statiska, så för varje samtal bestämmer avsändaren typen för varje kodek.\nfmtp #  Definierar ytterligare värden för en Payload Type. Detta är användbart för att kommunicera en viss videoprofil eller kodekinställning.\ncandidate #  Detta är en ICE-kandidat som kommer från ICE-agenten. Det här är en möjlig adress som WebRTC-agenten är tillgänglig på. Dessa förklaras i mer detalj i nästa kapitel.\nssrc #  En synkroniseringskälla (SSRC) definierar ett enda mediaströmspår.\nlabel är ID:t för den individuella strömmen. mslabel är ID:t för en container som kan innehålla flera strömmar.\nExempel på en WebRTC-sessionsbeskrivning #  Följande är en fullständig sessionsbeskrivning genererad av en WebRTC-klient:\nv=0 o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0 s=- t=0 0 a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E a=group:BUNDLE 0 1 m=audio 9 UDP/TLS/RTP/SAVPF 111 c=IN IP4 0.0.0.0 a=setup:active a=mid:0 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:111 opus/48000/2 a=fmtp:111 minptime=10;useinbandfec=1 a=ssrc:350842737 cname:yvKPspsHcYcwGFTw a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw a=ssrc:350842737 label:DfQnKjQQuwceLFdV a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates m=video 9 UDP/TLS/RTP/SAVPF 96 c=IN IP4 0.0.0.0 a=setup:active a=mid:1 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:96 VP8/90000 a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=sendrecv Det här är vad vi får reda på från det här meddelandet:\n Vi har två mediasektioner, en för ljud och en för video. Båda är sendrecv transceiver. Vi får två strömmar och vi kan skicka tillbaka två. Vi har ICE-kandidater och autentiseringsdetaljer, så vi kan försöka ansluta. Vi har ett certifikatfingeravtryck, så vi kan ha ett säkert samtal.  Ytterligare ämnen #  I senare versioner av denna bok kommer även följande ämnen att behandlas:\n Renegotiation Simulcast  "});index.add({'id':2,'href':'/sv/docs/03-connecting/','title':"Anslutning",'section':"Docs",'content':"Varför behöver WebRTC ett särskilt delsystem för anslutning? #  De flesta applikationer som distribueras idag upprättar klient/serveranslutningar. En klient/serveranslutning kräver att servern har en känd och publik adress. En klient ansluter till en server, och servern svarar.\nWebRTC använder inte en klient/server-modell utan skapar peer-to-peer (P2P) anslutningar. I en P2P-anslutning fördelas uppgiften att skapa en anslutning lika till båda parterna. Detta beror på att en publik nätverksadress (IP och port) är inget man kan förvänta sig i WebRTC, och den kan till och med ändras mitt under sessionen. WebRTC kommer att samla så mycket information som det går, och sedan göra allt den kan för sätta upp en dubbelriktad kommunikationsväg mellan två WebRTC-agenter.\nDet kan dock vara svårt att skapa peer-to-peer-anslutning. Dessa agenter kan finnas i olika nätverk utan direkt anslutning. I situationer där direkt anslutning finns kan du fortfarande ha andra problem. I vissa fall talar dina klienter inte samma nätverksprotokoll (UDP \u0026lt;-\u0026gt; TCP) eller kanske har olika IP-versioner (IPv4 \u0026lt;-\u0026gt; IPv6).\nTrots dessa svårigheter med att skapa en P2P-anslutning får du fördelar jämfört med traditionell klient/server-teknik på grund av följande funktioner WebRTC erbjuder.\nReducerade bandbreddskostnader #  Eftersom mediekommunikation sker direkt mellan klienterna behöver du inte betala för eller drifta en egen server för att vidarebefordra media.\nLägre latens #  Kommunikationen går snabbare när den är direkt! När en användare måste köra allt via din server gör det överföringarna långsammare.\nSäker E2E-kommunikation #  Direkt kommunikation är säkrare. Eftersom användarnas trafik inte går via din server, behöver de inte ens lita på att du inte dekrypterar den.\nHur fungerar det? #  Processen som beskrivs ovan kallas Interactive Connectivity Establishment (ICE). Ytterligare ett protokoll som är äldre än WebRTC.\nICE är ett protokoll som försöker hitta det bästa sättet att kommunicera mellan två ICE-agenter. Varje ICE-agent publicerar hur den kan nås, dessa kallas kandidater. En kandidat är i huvudsak en nätverksadress för agenten som den tror att den andra klienten kan nå. ICE bestämmer sedan det bästa hopkopplingen av klienterna.\nDen faktiska ICE-processen beskrivs mer detaljerat senare i detta kapitel. För att förstå varför ICE existerar är det bra att förstå vilket nätverksproblem vi behöver hantera.\nNätverksbegränsningar #  ICE handlar om att övervinna begränsningarna i dagens nätverk. Innan vi utforskar lösningen, låt oss prata om några vanliga problem.\nInte i samma nätverk #  För det mesta kommer den andra WebRTC-agenten inte ens att vara i samma nätverk. Ett typiskt samtal är vanligtvis mellan två WebRTC-agenter i olika nätverk utan direktanslutning.\nNedan är en figur som visar två distinkta nätverk, anslutna via internet. I varje nätverk har du två parter.\nFör parterna i samma nätverk är det mycket enkelt att ansluta. Kommunikation mellan 192.168.0.1 -\u0026gt; 192.168.0.2 är lätt att göra! Dessa två parter kan ansluta till varandra utan någon extern hjälp.\nEn värd som använder Router B har dock inget sätt att komma åt något bakom \u0026ldquo;Router A\u0026rdquo;. Hur kan den se skillnad på 191.168.0.1 bakom Router A och samma IP bakom Router B? De är privata IP-adresser! En värd som använder Router B kan skicka trafik direkt till Router A, men anropet slutar där. Hur vet Router A vilken värd den ska vidarebefordra meddelandet till?\nProtokollbegränsningar #  Vissa nätverk tillåter inte UDP-trafik alls, eller kanske tillåter de inte TCP. Vissa nätverk kan ha en mycket låg MTU (Maximum Transmission Unit, storleken på varje paket). Det finns många variabler som nätverksadministratörer kan ändra som kan göra det svårt att kommunicera.\nBrandvägg/IDS-regler #  En annan är \u0026ldquo;Deep Packet Inspection\u0026rdquo; och andra intelligenta filtreringar. Vissa nätverksadministratörer kommer att köra programvara som försöker bearbeta varje paket. Många gånger förstår inte denna programvara WebRTC, så den blockerar den eftersom den inte vet vad den ska göra, t.ex. behandlas WebRTC-paket som misstänkta UDP-paket när de kommer på en godtycklig port som inte är känd.\nNAT-kartläggning #  NAT (Network Address Translation) är den magi som gör anslutningen av WebRTC möjlig. Så här tillåter WebRTC att två parter i helt olika subnät kommunicerar och behandlar problemet \u0026ldquo;inte i samma nätverk\u0026rdquo; ovan. Medan det skapar nya utmaningar, låt oss förklara hur NAT Mapping fungerar först.\nDet använder inte ett relay, proxy eller server. Återigen har vi Agent 1 och Agent 2 och de finns i olika nätverk, men ändå flyter trafiken utan problem. Visualiserat ser det ut så här:\nFör att få denna kommunikation att upprätta skapar du en översättning med hjälp av NAT. Agent 1 använder port 7000 för att upprätta en WebRTC-anslutning med Agent 2. Detta skapar en koppling från 192.168.0.1:7000 till 5.0.0.1:7000. Detta gör det möjligt för Agent 2 att nå Agent 1 genom att skicka paket till 5.0.0.1:7000. Att skapa en NAT-mappning som i det här exemplet är som en automatisk version av att forward:a en port i din router.\nNackdelen med NAT är att det inte finns något konsekvent sätt att göra det på (t.ex. vidarebefordran av en statisk port), och att beteendet är olika i olika nätverk. Internetleverantörer och hårdvarutillverkare kan göra det på olika sätt. I vissa fall kan nätverksadministratörer till och med inaktivera det.\nDen goda nyheten är att hela beteendet är förstått och observerbart, så en ICE-agent kan bekräfta att den har satt upp NAT rätt och vet då alla inställningarna i mappningen.\nDokumentet som beskriver dessa beteenden är RFC 4787.\nSkapa en NAT-mappning #  Att skapa en NAT-mappning är den enkla biten. När du skickar ett paket till en adress utanför ditt nätverk skapas en mappning! En NAT-mappning är bara en tillfällig offentlig IP och port som tilldelas av din NAT. Det utgående meddelandet kommer att skrivas om så att dess källadress ges av den nyligen mappade adressen. Om ett meddelande skickas tillbaka till den adressen, så dirigeras det automatiskt tillbaka till värden bakom den NAT:ade interna adressen. Detaljerna kring NAT är där det blir komplicerat.\nOlika sorters NAT #  En NAT tillhör en av tre olika kategorier:\nSlutpunktoberoende mappning (Endpoint-Independent) #  En mappning skapas för varje avsändare i NAT:at nätverk. Om du skickar två paket till två olika adresser kommer NAT-mappningen att återanvändas. Båda parterna utanför det lokala nätet skulle se samma avsändare IP och port. Om de svarar, skulle det skickas tillbaka till samma lokala lyssnare.\nDetta är det bästa fallet. För att ett samtal ska fungera, MÅSTE åtminstone en av parterna vara av den här typen.\nAdressberoende mappning #  En ny mappning skapas varje gång du skickar ett paket till en ny adress. Om du skickar två paket till olika parter skapas två mappningar. Om du skickar två paket till samma part men till olika destinationsportar skapas INTE en ny mappning.\nAdress- och port-beroende mappning #  En ny mappning skapas om fjärr-IP:t eller porten är annorlunda. Om du skickar två paket till samma IP utanför det lokala nätet, men olika portar, skapas en ny mappning för varje.\nMappning av filtreringsbeteenden #  Mappningsfiltrering handlar om reglerna kring vem som får använda mappningen. Det finns tre liknande klassificeringar:\nSlutpunktsoberoende filtrering #  Vem som helst kan använda mappningen. Du kan dela mappningen med flera andra parter och de kan alla skicka trafik till den.\nAdressberoende filtrering #  Endast värden som mappningen skapades för kan använda mappningen. Om du skickar ett paket till agent A kan det svara tillbaka med så många paket som det vill. Om agent B försöker skicka ett paket till den mappningen ignoreras det.\nAdress- och port-beroende filtrering #  Endast IP:t och porten för vilken mappningen skapades för kan använda den. Om du skickar ett paket till agent A:5000 kan det svara tillbaka med så många paket som det vill. Om en agent A:5001 försöker skicka ett paket till samma mappningen ignoreras paketet.\nUppdatera en mappning #  Det rekommenderas att om en mappningen inte används på 5 minuter ska den förstöras. Detta är helt upp till ISP eller hårdvarutillverkaren.\nSTUN #  STUN (Session Traversal Utilities for NAT) är ett protokoll som skapades för att jobba med NATs. Det är ytterligare en teknik som skapats före WebRTC (och ICE!). Specifikationen hittar du i RFC 5389, som också definierar STUN-paketformatet. STUN-protokollet används också av ICE/TURN.\nSTUN är användbart eftersom det tillåter programmering av NAT mappning. Innan STUN kunde vi sätta upp ett NAT, men vi hade ingen aning om vilket IP och port det var! STUN ger dig inte bara möjligheten att skapa en NAT mappning, du får också detaljerna så att du kan dela dem med andra så att de kan skicka trafik till dig via den mappning du just skapade.\nLåt oss börja med en grundläggande beskrivning av STUN. Senare kommer vi att utöka TURN- och ICE-användningen. För närvarande ska vi bara beskriva flödet för begäran / svar för att skapa en kartläggning. Sedan kommer vi att prata om hur man får detaljerna i den att dela med andra. Detta är processen som händer när du har en stun:-server i dina ICE-URL:er för en WebRTC PeerConnection. Kort sagt, STUN hjälper en server bakom ett NAT:at nätverk att lista ut vilken mappning som skapades genom att fråga en STUN-server utanför det lokala nätverket vad den kan se.\nProtokollstruktur #  Varje STUN-paket har följande format:\n 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN Meddelande typ #  Varje STUN-paket har en typ. Just nu bryr vi oss bara om följande två:\n Bindningsförfrågan - 0x0001 Bindningssvar - 0x0101  För att skapa en NAT-mappning gör vi ett Binding Request. Sedan svarar servern med ett Binding Response.\nMeddelandets längd #  Hur långt avsnittet Data är. Detta avsnitt innehåller godtycklig data som definieras av Message Type.\nMagic Cookie #  Det fasta värdet 0x2112A442 i nätverksbyteordning (network byte order), det hjälper till att skilja STUN-trafik från andra protokoll.\nTransaktions ID #  En 96-bitars identifierare som unikt identifierar en begäran/svar. Detta hjälper dig att para ihop dina begäran och svar.\nData #  Data kommer att innehålla en lista med STUN-attribut. Ett STUN-attribut har följande struktur:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Value (variable) .... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Ett STUN Binding Request använder inga attribut. Det betyder att en STUN Binding Request endast innehåller en header.\nEn STUN Binding Response använder en XOR-MAPPED-ADDRESS (0x0020). Detta attribut innehåller en IP och port. Detta är IP och port för den NAT-mappning som skapas!\nSkapa en NAT-mappning #  Att skapa en NAT-mappning med STUN kräver bara att skicka en begäran! Du skickar ett STUN Binding Request till STUN-servern. STUN-servern svarar sedan med en STUN Binding Response. Denna STUN Binding Response kommer att innehålla en Mapped Address. Den \u0026ldquo;mappade adressen\u0026rdquo; är hur STUN-servern ser dig. Det är din \u0026ldquo;NAT-mappning\u0026rdquo;. Den \u0026ldquo;mappade adressen\u0026rdquo; är vad du skulle dela om du vill att någon ska skicka paket till dig.\nDin \u0026ldquo;mappade adress\u0026rdquo; kallas också för ditt \u0026ldquo;publika IP\u0026rdquo; eller ibland Server Reflexive Candidate.\nBestämma NAT-typ #  Tyvärr kan en \u0026ldquo;mappad adress\u0026rdquo; kanske ändå inte vara användbar. Om reglerna är \u0026ldquo;adressberoende\u0026rdquo; (Address Dependent) kan bara STUN-servern skicka trafik till dig. Om du delade adressen och en annan agent försöker skicka meddelanden kommer de att ignoreras. Detta gör det värdelöst för att kommunicera med andra. Du kanske tycker att fallet \u0026ldquo;adressberoende\u0026rdquo; faktiskt går att lösa om STUN-servern också kan vidarebefordra paket åt dig till din andra part! Detta leder oss till en annan teknik, TURN.\nRFC 5780 definierar en metod för att göra ett test för att lista ut din NAT-typ. Detta är användbart eftersom du kan veta i förväg om direktanslutning var möjlig.\nTURN #  TURN (Traversal Using Relays around NAT) definieras i [RFC 5766] (https://tools.ietf.org/html/rfc5766) är lösningen när direktanslutning inte är möjlig. Det kan bero på att du har två NAT-typer som är oförenliga eller kanske inte kan tala samma protokoll! TURN kan också användas för sekretessändamål. Genom att köra all din kommunikation genom TURN döljer du klientens faktiska adress.\nTURN använder en dedikerad server. Denna server fungerar som en proxy för en klient. Klienten ansluter till en TURN-server och skapar en allokering (Allocation). Genom att skapa en allokering får en klient en tillfällig IP/port/protokoll som kan användas för att skicka trafik tillbaka till klienten. Den här nya lyssnaren kallas en Relayed Transport Address. Tänk på det som en vidarebefordringsadress, du använder den så att andra kan skicka dig trafik via TURN! För varje klient du ger din Relay Transport Address till måste du skapa ett nytt \u0026ldquo;tillstånd\u0026rdquo; (Permission) för att tillåta kommunikation med dig.\nNär du skickar utgående trafik via TURN skickas den via din Relayed Transport Address. När en annan klient får trafik ser den ut att komma från TURN-servern.\nTURN Livscykel #  Följande är allt som en klient som vill skapa en TURN-allokering måste göra. Kommunikation med någon som använder TURN kräver inga ändringar. Den andra klienten får ett IP och en port, och de kommunicerar med den som vilken annan server som helst.\nTilldelningar (Allocations) #  Tilldelningar är kärnan i TURN. En \u0026ldquo;allokering\u0026rdquo; är i grunden en \u0026ldquo;TURN Session\u0026rdquo;. För att skapa en TURN-allokering kommunicerar du med en TURN Server Transport Address (vanligtvis på port 3478).\nNär du skapar en tilldelning måste du ange följande:\n Användarnamn/lösenord - För att skapa TURN-tilldelningar krävs autentisering Allokeringstransport - Den \u0026lsquo;vidarebefordrade transportadressen\u0026rsquo; kan vara UDP eller TCP Even-Port - Du kan begära sekventiella portar för flera tilldelningar, inte relevanta för WebRTC.  Om begäran lyckades får du svar med TURN-servern med följande STUN-attribut i Data-sektionen:\n XOR-MAPPED-ADRESS - Mappad adress för din TURN Client. När någon skickar data till \u0026ldquo;Relayed Transport Address\u0026rdquo;, vidarebefordras den till. RELAYED-ADRESS - Det här är adressen som du ger ut till andra klienter. Om någon skickar ett paket till den här adressen vidarebefordras det till TURN-klienten. LIFETIME- Hur länge tills denna TURN-fördelning tas bort. Du kan förlänga livslängden genom att skicka ett uppdaterings anrop (Refresh).  Behörigheter #  En klient kan inte skicka till din Relayed Transport Address förrän du skapar ett tillstånd för den. När du skapar en behörighet berättar du för TURN-servern att denna IP och Port får skicka inkommande trafik.\nKlienten måste ge dig IP och port som den ser ut för TURN-servern. Det betyder att den ska skicka ett STUN Binding Request till TURN-servern. Ett vanligt felfall är att en klient skickar ett STUN Binding Request till en annan server. De kommer då att be dig skapa en behörighet för denna IP.\nLåt oss säga att du vill skapa en behörighet (permission) för en klient bakom en \u0026ldquo;adressberoende mappning\u0026rdquo;. Om du genererar en \u0026ldquo;mappad adress\u0026rdquo; från en annan TURN-server kommer all inkommande trafik att ignoreras. Varje gång de kommunicerar med en annan klient genererar den en ny mappning. Behörigheterna löper ut efter 5 minuter om de inte uppdateras.\nSendIndication/ChannelData #  Dessa två meddelanden är avsedda för TURN-klienten att skicka meddelanden till en klient.\nSendIndication är ett fristående meddelande. Det innehåller den information du vill skicka, och vem du vill skicka den till. Detta är slösaktigt om du skickar många meddelanden till en annan klient. Om du skickar 1000 meddelanden kommer du att upprepa deras IP-adress 1000 gånger!\nChannelData låter dig skicka data, utan att upprepa IP-adressen. Du skapar en kanal med en IP och port. Du skickar sedan med ChannelId och IP och port fylls i på serversidan. Detta är bättre om du skickar många av meddelanden.\nRefreshing #  Allokeringar kommer att ta bort sig själva automatiskt. TURN-klienten måste uppdatera dem innan deras LIFETIME som ges när tilldelningen skapas går ut.\nTURN Användning #  TURN Användningen finns i två former. Vanligtvis har du en part som fungerar som en \u0026ldquo;TURN klient\u0026rdquo; och den andra sidan kommunicerar direkt. I vissa fall kan du ha TURN-server på båda sidor, till exempel för att båda klienterna finns i nätverk som blockerar UDP, och därför sker anslutningen till respektive TURN-servrar via TCP.\nDessa figurer hjälper till att illustrera hur det skulle se ut.\nEn TURN allokering för kommunikation #  Två TURN allokeringar för kommunikation #  ICE #  ICE (Interactive Connectivity Establishment) är tekniken WebRTC använder för att ansluta två klienter med varandra. Definierad i RFC 8445, detta är ytterligare en standard som är återanvänd i WebRTC. ICE är ett protokoll för att sätta upp av anslutningar. Det hittar alla möjliga rutter (routes) mellan de två klienterna och säkerställer att de kan kommunicera med varandra.\nDessa rutter är kända som Candidate Pairs, vilket är en anslutning mellan en lokal och en extern adress. Det är här STUN och TURN används tillsammans med ICE. Dessa adresser kan vara din lokala IP-adress plus en port, \u0026ldquo;NAT-mappning\u0026rdquo; eller en Relayed Transport Address. Båda klienterna listar alla adresser de vill använda, skickar över dem och försöker sedan ansluta.\nTvå ICE-agenter kommunicerar med hjälp av ICE-ping-paket (connectivity checks) för att sätta upp en anslutning. När anslutningen har upprättats kan de skicka vilken data de vill. Det blir som att använda en normal socket. Dessa kontroller använder STUN-protokollet.\nSkapa en ICE-agent #  En ICE-agent är antingen Controlling eller Controlled. Den \u0026ldquo;kontrollerande\u0026rdquo; agenten är den som bestämmer vilken kandidat (Candidate Pair) som ska användas. Vanligtvis är den klient som skickar erbjudandet den kontrollerande sidan.\nVarje klient måste ha ett \u0026ldquo;användarfragment\u0026rdquo; (user fragment) och ett \u0026ldquo;lösenord\u0026rdquo; (password). Dessa två värden måste utbytas innan anslutningskontroller kan göras. \u0026ldquo;Användarfragmentet\u0026rdquo; skickas i klartext och är användbart för att separera (demuxing) flera ICE-sessioner. Lösenordet används för att generera attributet MESSAGE-INTEGRITY. I slutet av varje STUN-paket finns det ett attribut som är en hash för hela paketet med \u0026ldquo;lösenordet\u0026rdquo; som en nyckel. Detta används för att autentisera paketet och se till att det inte har blivit manipulerat.\nFör WebRTC skickas alla dessa värden via \u0026ldquo;sessionsbeskrivningen\u0026rdquo; som beskrevs i förra kapitlet.\nKandidatsamling #  Vi måste nu samla alla möjliga adresser vi kan nås på. Dessa adresser kallas kandidater. Dessa kandidater skickas också via \u0026ldquo;sessionsbeskrivningen\u0026rdquo;.\nKlient #  En klientkandidat lyssnar direkt på ett lokalt nätverksinterface, antingen via UDP eller TCP.\nmDNS #  En mDNS-kandidat liknar en klientkandidat, men IP-adressen är dold. Istället för att informera den andra sidan om din IP-adress, ger du dem ett UUID som värdnamn. Du ställer istället upp en multicast-lyssnare och svarar om någon frågar efter det UUID som du publicerat.\nOm du är i samma nätverk som agenten kan du hitta varandra via multicast. Om du inte är i samma nätverk kommer du inte att kunna ansluta (om inte nätverksadministratören uttryckligen konfigurerat nätverket så att multicast-paket kan passera).\nDetta är användbart för sekretessändamål. En användare kan ta reda på din lokala IP-adress via WebRTC med en klientkandidat (utan att ens försöka ansluta till dig), men med en mDNS-kandidat får de nu bara ett slumpmässigt UUID.\nServerreflexiv kandidat #  En serverreflexiv kandidat genereras genom att göra ett STUN Binding Request till en STUN-server.\nNär du får en STUN Binding Response, är XOR-MAPPED-ADDRESS din serverreflexiva kandidat.\nPeer Reflexive #  En Peer Reflexive-kandidat är när du får en inkommande begäran från en adress som du inte känner till. Eftersom ICE är ett autentiserat protokoll vet du att trafiken är giltig. Detta betyder bara att den andra klienten försöker kommunicera med dig från en extern adress den ännu inte känner till.\nDetta händer ofta när en \u0026ldquo;klientkandidat\u0026rdquo; kommunicerar med en \u0026ldquo;serverreflexiv kandidat\u0026rdquo;. En ny \u0026ldquo;NAT-mappning\u0026rdquo; skapades eftersom du kommunicerar utanför ditt subnät. Kommer du ihåg att vi sa att anslutningskontrollerna faktiskt är STUN-paket? Formatet för STUN-svar tillåter naturligtvis en peer att rapportera tillbaka den peer-reflexiva adressen.\nRelä (Relay) #  En reläkandidat genereras med hjälp av en TURN-server.\nEfter den första handskakningen med TURN-servern får du en RELAYED-ADDRESS, detta är din reläkandidat.\nAnslutningskontroller #  Vi känner nu till den andra klientens \u0026ldquo;användarfragment\u0026rdquo;, \u0026ldquo;lösenord\u0026rdquo; och kandidater. Vi kan nu försöka ansluta! Alla kandidater matchas med varandra, så om du har 3 kandidater på varje sida har du nu 9 kandidatpar.\nVisuellt ser det ut så här:\nKandidatval #  Den kontrollerande och kontrollerade agenten skickar a trafik över varje par. Detta behövs om en agent står bakom en \u0026ldquo;adressberoende mappning\u0026rdquo; (Address Dependent Mapping). Detta kommer att skapa en ny \u0026ldquo;peer reflexive kandidat\u0026rdquo;.\nVarje \u0026ldquo;kandidatpar\u0026rdquo; som lyckades skicka nätverkstrafik befordras till ett \u0026ldquo;giltigt kandidatpar\u0026rdquo;. Den kontrollerande agenten nominerar sedan ett giltigt kandidatpart. Detta blir det \u0026ldquo;nominerade paret\u0026rdquo;. Den kontrollerande och kontrollerade agenten försöker sedan ytterligare en runda dubbelriktad kommunikation. Om det lyckas blir det \u0026ldquo;nominerade paret\u0026rdquo; det \u0026ldquo;utvalda kandidatparet\u0026rdquo; (Selected Candidate Pair)! Detta par används sedan under resten av sessionen.\nStartar om #  Om ditt Selected Candidate Pair slutar fungera av någon anledning (NAT-mappning upphör att gälla, TURN-server kraschar) kommer ICE-agenten att få status Failed. Båda agenterna kan startas om och kommer att göra hela processen om igen.\n"});index.add({'id':3,'href':'/sv/docs/04-securing/','title':"Säkerhet",'section':"Docs",'content':"Säkerhet och WebRTC #  Varje WebRTC-anslutning är autentiserad och krypterad. Du kan vara säker på att en tredje part inte kan se vad du skickar eller infoga falska meddelanden. Du kan också vara säker på att WebRTC-agenten som genererade sessionsbeskrivningen är den du kommunicerar med.\nDet är mycket viktigt att ingen kan modifiera dina meddelanden. Det är ok om en tredje part läser sessionsbeskrivningen under transport. WebRTC har dock inget skydd mot att det ändras. En angripare kan utföra en man-i-mitten-attack genom att ändra ICE-kandidaterna och uppdatera certifikatets fingeravtryck.\nHur fungerar det? #  WebRTC använder två befintliga protokoll, Datagram Transport Layer Security (DTLS) och Secure Real-time Transport Protocol (SRTP).\nMed DTLS kan du sätta upp en session och sedan utbyta data säkert mellan två parter. Det är ett syskon till TLS, samma teknik som används för HTTPS, men DTLS använder UDP istället för TCP som transportlager. Det betyder att protokollet måste hantera tappade paket. SRTP är speciellt utformat för säkert skicka ljud och bild. Det finns några optimeringar vi kan göra genom att använda det protokollet istället för DTLS.\nDTLS används först. Det gör en handskakning över anslutningen från ICE. DTLS är ett klient/serverprotokoll, så en sida måste starta handskakningen. Klient/serverroller väljs under uppsättningen. Under DTLS-handskakningen erbjuder båda sidor ett certifikat. När handskakningen är klar jämförs detta certifikat med certifikat-hashen i sessionsbeskrivningen. Detta för att säkerställa att handskakningen gjorts med den WebRTC-agent du förväntade dig. DTLS-anslutningen kan sen användas för vanlig DataChannel-kommunikation.\nFör att skapa en SRTP-session initialiserar vi den med hjälp av nycklarna som genereras med DTLS. SRTP har ingen handskakningsmekanism, så vi måste använda nycklar som genererats på något annat sätt. När detta är gjort kan vi skicka media krypterat över SRTP!\nGrundläggande säkerhet #  För att förstå tekniken som presenteras i detta kapitel finns det några termer som är bra att känna till. Kryptografi är ett knepigt ämne så det kan vara värt att konsultera andra källor också.\nKlartext och Kryptotext #  Klartext är originaltexten man skickar in till ett chiffer. Kryptotext är resultatet av en chiffer.\nKryptering #  Ett chiffer är en serie steg som tar vanlig text till kryptotext. Chiffret kan sedan vändas så att du kan ta din kryptotext tillbaka till klartext. Ett chiffer har vanligtvis en nyckel för att ändra sitt beteende. En annan term för detta är kryptering och dekryptering.\nEtt enkelt chiffer är ROT13. Varje bokstav flyttas 13 tecken framåt. För att dekryptera chiffret flyttar du 13 tecken bakåt. Den klara texten HEJSAN skulle bli krypteringstexten URWFNA. I det här fallet är krypteringen ROT och nyckeln är 13.\nHashfunktioner #  Hash är en enkelriktad funktion som genererar en kontrollsumma. Från samma meddelande genererar den samma kontrollsumma varje gång. Det är viktigt att funktionen inte är reversibel. Om du har en kontrollsumma ska du inte kunna lista ut meddelandet som den genererades från. Hashing är användbart när du vill bekräfta att ett meddelande inte har manipulerats.\nEn enkel hash funktion skulle vara att bara ta varannan bokstav. HEJSAN skulle bli HJA. Du kan inte anta att HEJSAN var ingången, men du kan bekräfta att HEJSAN skulle vara en matcha kontrollsumman.\nKryptografi för offentlig / privat nyckel #  Public/Private Key Cryptography beskriver vilken typ av kod som DTLS och SRTP använder. I det här systemet har du två nycklar, en offentlig och en privat nyckel. Den offentliga nyckeln är för kryptering av meddelanden och är säker att dela. Den privata nyckeln är för dekryptering och ska aldrig delas. Det är den enda nyckeln som kan dekryptera meddelanden som är krypterade med den offentliga nyckeln.\nDiffie–Hellmans nyckelöverföring #  Diffie–Hellman nyckelöverföring tillåter två användare som aldrig har träffats tidigare att skapa en delad hemlighet säkert över internet. Användaren A kan skicka en hemlighet till användaren B utan att oroa sig för avlyssning. Detta beror på svårigheten att bryta det diskreta logaritmproblemet. Du behöver inte helt förstå hur det fungerar, men det är bra att veta att det här är tekniken DTLS-handskakningen är baserad på.\nWikipedia har ett exempel på hur det fungerar här.\nPseudorandom-funktioner #  En Pseudorandom-funktion (PRF) är en fördefinierad funktion för att generera ett värde som verkar slumpmässigt. Det kan ta flera indata och generera en enda utdata.\nKey Derivation Function #  Key Derivation är en typ av pseudorandom-funktion. Key Derivation är en funktion som används för att göra en nyckel starkare. Ett vanligt sätt är nyckelsträckning (key stretching).\nLåt oss säga att du får en nyckel som är 8 byte. Du kan använda en KDF för att göra den starkare.\nNonce #  En nonce är ytterligare indata till ett chiffer. Detta är så att du kan få olika utdata från krypteringen, även om du krypterar samma meddelande flera gånger.\nOm du krypterar samma meddelande tio gånger kommer krypteringen att ge dig samma kryptotext 10 gånger. Genom att använda ett nonce kan du få olika indata medan du fortfarande använder samma nyckel. Det är viktigt att du använder ett nytt nonce för varje meddelande! Annars ger det ger det inte någon extra säkerhet.\nMeddelandeautentiseringskod #  En meddelandeautentiseringskod (Message Authentication Code) är en hash som placeras i slutet av ett meddelande. En MAC visar att meddelandet kommer från den användare du förväntade dig.\nOm du inte använder en MAC kan en angripare infoga ogiltiga meddelanden. Efter dekryptering skulle du bara ha skräp eftersom de inte vet nyckeln.\nNyckelrotation #  Nyckelrotation är praxis att byta ut nyckeln med jämna mellanrum. Detta gör att det inte är lika allvarligt att en nyckel blivit stulen. Om en nyckel blir stulen eller har läckt är det mindre data som kan dekrypteras.\nDTLS #  DTLS (Datagram Transport Layer Security) tillåter två klienter att etablera säker kommunikation utan någon befintlig konfiguration. Även om någon lyssnar på konversationen kan de inte dekryptera meddelandena.\nFör att en DTLS-klient och en server ska kunna kommunicera måste de komma överens om ett chiffer och en nyckel. De bestämmer dessa värden genom att göra ett DTLS-handskakning. Under handskakningen är meddelandena i klartext. När en DTLS-klient och server har utbytt tillräckligt med information för att börja kryptera skickar den en Change Cipher Spec. Efter detta meddelande kommer varje efterföljande meddelande att vara krypterat!\nPaketformat #  Varje DTLS-paket börjar med en rubrik.\nInnehållstyp #  Du kan förvänta dig följande typer (Content Type):\n 20 - Ändra krypteringsspecifikation (Change Cipher Spec) 22 - Handskakning (Handshake) 23 - Applikationsdata (Application Data)  Handskakning används för att utbyta detaljer för att starta sessionen. Ändra krypteringsspecifikation används för att meddela den andra sidan att allt kommer att krypteras. Applikationsdata är de krypterade meddelandena.\nVersion #  Version kan antingen vara 0x0000feff (DTLS v1.0) eller 0x0000fefd (DTLS v1.2) det finns ingen v1.1.\nEpoch #  Epoken börjar vid 0 men blir 1 efter en Ändra krypteringsspecifikation. Alla meddelanden med en epok som inte är noll är krypterade.\nSekvensnummer #  Sekvensnummer används för att hålla meddelanden i ordning. Varje meddelande ökar sekvensnumret. När epoken ökas börjar sekvensnumret om.\nLängd och data #  Datan (Payload) som skickas är specifik för varje \u0026ldquo;innehållstyp\u0026rdquo; (Content Type). För en Applikationsdata är det krypterad data. För Handskakning kommer det att vara olika beroende på meddelandet. Längden säger bara hur stor datan är.\nHandskakningens tillstånd #  Under handskakningen utbyter klienten och servern en serie meddelanden. Dessa meddelanden grupperas i stegar. Varje stege kan ha flera meddelanden (eller bara ett). En stege är inte klar förrän alla meddelanden i stegen har tagits emot. Vi kommer att beskriva syftet med varje meddelande mer detaljerat nedan.\nClientHello #  ClientHello är det första meddelandet som skickas av klienten. Den innehåller en lista med attribut. Dessa attribut berättar för servern vilka chiffer och funktioner som klienten stöder. För WebRTC så väljer vi också SRTP-chiffer med ClientHello. Den innehåller också slumpmässig data som kommer att användas för att generera nycklarna för sessionen.\nHelloVerifyRequest #  HelloVerifyRequest skickas av servern till klienten. Det är för att se till att klienten avsåg att skicka begäran. Klienten skickar sedan ClientHello igen, men med ett token den fick från HelloVerifyRequest:et.\nServerHello #  ServerHello är svaret från servern för konfigurationen av sessionen. Den innehåller vilket chiffer som ska användas när den här sessionen är klar. Den innehåller också serverns slumpmässiga data.\nCertifikat #  Certifikatet (Certificate) innehåller certifikatet för klienten eller servern. Detta används för att unikt identifiera vem vi kommunicerade med. Efter att handskakningen är över ser vi till att detta certifikat när det hashas matchar fingeravtrycket i SessionDescription.\nServerKeyExchange/ClientKeyExchange #  Dessa meddelanden används för att överföra den offentliga nyckeln. Vid start genererar klienten och servern båda ett knappsats. Efter handskakningen kommer dessa värden att användas för att generera en Pre-Master Secret.\nCertificateRequest #  En CertificateRequest skickas av servern som meddelar klienten att den vill ha ett certifikat. Servern kan antingen begära eller kräva ett certifikat.\nServerHelloDone #  ServerHelloDone meddelar klienten att servern är klar med handskakningen.\nCertificateVerify #  CertificateVerify är hur avsändaren visar att den har den privata nyckeln som skickas i certifikatmeddelandet.\nChangeCipherSpec #  ChangeCipherSpec informerar mottagaren om att allt som skickas efter detta meddelande kommer att krypteras.\nFärdiga #  Färdig (Finished) är krypterat och innehåller en hash av alla skickade meddelanden. Det används för att verifiera att handskakningen inte har blivit manipulerad.\nNyckelgenerering #  När handskakningen är klar kan du börja skicka krypterad data. Chiffret valdes av servern och finns i ServerHello. Men hur valdes nyckeln?\nFörst genererar vi en Pre-Master Secret. För att göra det värde används Diffie–Hellman på nycklarna som byts via ServerKeyExchange och ClientKeyExchange. Detaljerna varierar beroende på vilket chiffer vi valt.\nDärefter genereras en Master Secret. Varje version av DTLS har en egen pseudorandom-funktion. För DTLS 1.2 tar funktionen Pre-Master Secret och slumpvärdena i ClientHello och ServerHello. Resultatet från att köra pseudorandom-funktionen är vår Master Secret som används för chiffret.\nUtbyta applikationsdata #  Arbetshästen för DTLS är ApplicationData. Nu när vi har ett initialiserat chiffer kan vi börja kryptera och skicka data.\nMeddelanden med applikationsdata använder den DTLS-header vi beskrev tidigare. Datan är skickas som krypterad text. Du har nu en fungerande DTLS-session och kan kommunicera säkert.\nDTLS har många fler intressanta funktioner som till exempel omförhandling (renegotiation). Men eftersom de inte används i WebRTC hoppar vi över det.\nSRTP #  SRTP är ett protokoll utformat speciellt för kryptering av RTP-paket. För att starta en SRTP-session anger du dina nycklar och chiffer. Till skillnad från DTLS har den ingen handskakningsmekanism. All konfiguration och nycklar genererades under DTLS-handskakningen.\nDTLS tillhandahåller ett dedikerat API för att exportera nycklarna som ska användas av en annan process. Detta definieras i RFC 5705.\nSessionsskapande #  SRTP definierar en Key Derivation-funktion som används på indatat. När du skapar en SRTP-session skickas indatat genom funktionen för att generera nycklar för vår SRTP-kryptering. Efter detta kan du gå vidare till att skicka ljud och bild.\nUtbyta media #  Varje RTP-paket har ett 16-bitars sekvensnummer. Dessa sekvensnummer används för att hålla ordning på paket, som en primär nyckel. Under ett samtal kommer numret bli för stort och \u0026ldquo;rulla över\u0026rdquo;. SRTP håller reda på det och kallar detta för övergångsräknare (rollover counter).\nVid kryptering av ett paket använder SRTP övergångsräknaren och sekvensnumret som ett nonce. Detta för att säkerställa att även om du skickar samma data två gånger kommer krypteringstexten att vara annorlunda. Detta är viktigt för att förhindra att en angripare identifierar mönster eller försöker en uppspelningsattack (replay attack).\n"});})();