<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="WebRTC具有哪些安全性保障？ #  每个WebRTC连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的WebRTC Agent正是生成会话描述的Agent。
没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC无法防止会话描述被修改。攻击者可以通过更改ICE候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。
译注：这里指的是，P2P连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过man-in-the-middle方式伪装中间人同时与通信双方建立连接并通信。  它是如何做到的？ #  WebRTC使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / DTLS）和 安全实时传输协议（Secure Real-time Transport Protocol / SRTP）。
DTLS使你可以协商会话，然后在两个peer之间安全地交换数据。它是TLS的同类产品，TLS是HTTPS所使用的技术，而DTLS与TLS的区别仅在与其使用UDP而不是TCP作为其传输层。这也意味着DTLS协议必须处理不可靠的数据传输。SRTP是专为安全的交换媒体数据而设计的。相对于DTLS而言，使用SRTP对传输媒体数据有一些优化。
DTLS先被使用。它通过ICE提供的连接进行一次握手。DTLS是一种客户端/服务器协议，因此其中一侧需要开始握手。客户端/服务器的角色是在信令中被确定的。在DTLS握手期间，双方都会提供证书。 握手完成后，需要将收到的证书与会话描述中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的WebRTC Agent。接下来，可以将DTLS连接用于DataChannel通信。
要创建SRTP会话，我们使用DTLS生成的密钥对其进行初始化。SRTP没有握手机制，因此必须使用外部密钥进行引导。一旦完成此操作，媒体数据即可以用SRTP加密并进行交换！
安全性101 #  要了解本章介绍的技术，你首先需要了解这些术语。密码学是一个棘手的主题，因此其他资源也是值得参考的！
明文和密文 #  明文是cipher的输入。密文是cipher的输出。
Cipher #  Cipher是将明文转换为密文的一系列步骤。Cipher可以反过来运行，因此你可以将密文恢复为明文。一个cipher通常拥有一个更改其行为的密钥。还有一个术语是加密和解密。
举例来说，一个简单的cipher是ROT13。也就是每个字母向前移动13个字符。要解密这个cipher，需要每个字母向后移动13个字符。明文HELLO将成为密文URYYB。 在这种情况下，Cipher是ROT，密钥是13。
明文/密文 #  明文是cipher的输入。密文是cipher的输出。
哈希函数 #  哈希函数是一种生成摘要的单向过程。给定一个输入，它每次都会生成相同的输出。其重要特点是输出不可逆。也就是说，根据输出的摘要，无法确定其输入。当你要确认消息未被篡改时，哈希函数很有用。
举例来说，一个简单的哈希函数的作用仅仅是将所有其他字母HELLO变成HLO。你不能认为HELLO就是输入，但可以确认如果输入的是HELLO，那么结果是匹配的。
公钥/私钥加密 #  公钥/私钥加密描述了DTLS和SRTP使用的cipher类型。在此系统中，你有两个密钥，即公钥和私钥。公钥用于加密消息，可以安全共享。 私钥用于解密消息，永远不应共享。当解密那些使用对应的公钥加密的消息时，它是唯一的密钥。
Diffie-Hellman交换 #  Diffie-Hellman交换允许两个以前从未见过的用户通过Internet安全的创建一个共享的秘密信息。用户A可以将秘密信息发送给用户B，而不必担心被窃听。破解该信息的难度将取决于破解离散对数问题的难度。 你不必完全理解该算法是如何工作的，但这可以帮助你了解是什么使得DTLS握手变得可行的。
Wikipedia在此处中有一个实际的例子。
伪随机函数（PRF） #  伪随机函数是一个预定义函数，用于生成随机出现的值。它可能需要多个输入并生成一个输出。
密钥派生（KDF） #  密钥派生是一类伪随机函数。是一种用于增强密钥的安全性的方法。一种常见的模式是密钥扩展。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="安全性"><meta property="og:description" content="WebRTC具有哪些安全性保障？ #  每个WebRTC连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的WebRTC Agent正是生成会话描述的Agent。
没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC无法防止会话描述被修改。攻击者可以通过更改ICE候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。
译注：这里指的是，P2P连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过man-in-the-middle方式伪装中间人同时与通信双方建立连接并通信。  它是如何做到的？ #  WebRTC使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / DTLS）和 安全实时传输协议（Secure Real-time Transport Protocol / SRTP）。
DTLS使你可以协商会话，然后在两个peer之间安全地交换数据。它是TLS的同类产品，TLS是HTTPS所使用的技术，而DTLS与TLS的区别仅在与其使用UDP而不是TCP作为其传输层。这也意味着DTLS协议必须处理不可靠的数据传输。SRTP是专为安全的交换媒体数据而设计的。相对于DTLS而言，使用SRTP对传输媒体数据有一些优化。
DTLS先被使用。它通过ICE提供的连接进行一次握手。DTLS是一种客户端/服务器协议，因此其中一侧需要开始握手。客户端/服务器的角色是在信令中被确定的。在DTLS握手期间，双方都会提供证书。 握手完成后，需要将收到的证书与会话描述中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的WebRTC Agent。接下来，可以将DTLS连接用于DataChannel通信。
要创建SRTP会话，我们使用DTLS生成的密钥对其进行初始化。SRTP没有握手机制，因此必须使用外部密钥进行引导。一旦完成此操作，媒体数据即可以用SRTP加密并进行交换！
安全性101 #  要了解本章介绍的技术，你首先需要了解这些术语。密码学是一个棘手的主题，因此其他资源也是值得参考的！
明文和密文 #  明文是cipher的输入。密文是cipher的输出。
Cipher #  Cipher是将明文转换为密文的一系列步骤。Cipher可以反过来运行，因此你可以将密文恢复为明文。一个cipher通常拥有一个更改其行为的密钥。还有一个术语是加密和解密。
举例来说，一个简单的cipher是ROT13。也就是每个字母向前移动13个字符。要解密这个cipher，需要每个字母向后移动13个字符。明文HELLO将成为密文URYYB。 在这种情况下，Cipher是ROT，密钥是13。
明文/密文 #  明文是cipher的输入。密文是cipher的输出。
哈希函数 #  哈希函数是一种生成摘要的单向过程。给定一个输入，它每次都会生成相同的输出。其重要特点是输出不可逆。也就是说，根据输出的摘要，无法确定其输入。当你要确认消息未被篡改时，哈希函数很有用。
举例来说，一个简单的哈希函数的作用仅仅是将所有其他字母HELLO变成HLO。你不能认为HELLO就是输入，但可以确认如果输入的是HELLO，那么结果是匹配的。
公钥/私钥加密 #  公钥/私钥加密描述了DTLS和SRTP使用的cipher类型。在此系统中，你有两个密钥，即公钥和私钥。公钥用于加密消息，可以安全共享。 私钥用于解密消息，永远不应共享。当解密那些使用对应的公钥加密的消息时，它是唯一的密钥。
Diffie-Hellman交换 #  Diffie-Hellman交换允许两个以前从未见过的用户通过Internet安全的创建一个共享的秘密信息。用户A可以将秘密信息发送给用户B，而不必担心被窃听。破解该信息的难度将取决于破解离散对数问题的难度。 你不必完全理解该算法是如何工作的，但这可以帮助你了解是什么使得DTLS握手变得可行的。
Wikipedia在此处中有一个实际的例子。
伪随机函数（PRF） #  伪随机函数是一个预定义函数，用于生成随机出现的值。它可能需要多个输入并生成一个输出。
密钥派生（KDF） #  密钥派生是一类伪随机函数。是一种用于增强密钥的安全性的方法。一种常见的模式是密钥扩展。"><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/04-securing/"><meta property="article:modified_time" content="2021-07-13T20:52:21+08:00"><meta property="og:site_name" content="给好奇者的WebRTC"><title>安全性 | 给好奇者的WebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/zh.search.min.5c99b86983222b55489e03f7a5fec77cc785d5dfb392184c58430c08d40cc028.js integrity="sha256-XJm4aYMiK1VIngP3pf7HfMeF1d+zkhhMWEMMCNQMwCg="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/zh><span>给好奇者的WebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/02-signaling/>信令</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>连接</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/ class=active>安全性</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/05-real-time-networking/>搭建实时网络</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>媒体通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>数据通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/>WebRTC应用场景</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>调试</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/11-faq/>常见问题</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/12-glossary/>Glossary</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>安全性</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#它是如何做到的>它是如何做到的？</a></li><li><a href=#安全性101>安全性101</a><ul><li></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#数据包格式>数据包格式</a></li><li><a href=#握手状态机><code>握手</code>状态机</a></li><li><a href=#密钥的生成>密钥的生成</a></li><li><a href=#交换applicationdata>交换ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#会话创建>会话创建</a></li><li><a href=#交换媒体数据>交换媒体数据</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=webrtc具有哪些安全性保障>WebRTC具有哪些安全性保障？
<a class=anchor href=#webrtc%e5%85%b7%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%80%a7%e4%bf%9d%e9%9a%9c>#</a></h1><p>每个WebRTC连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的WebRTC Agent正是生成会话描述的Agent。</p><p>没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC无法防止会话描述被修改。攻击者可以通过更改ICE候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。</p><blockquote class="book-hint info">译注：这里指的是，P2P连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过man-in-the-middle方式伪装中间人同时与通信双方建立连接并通信。</blockquote><h2 id=它是如何做到的>它是如何做到的？
<a class=anchor href=#%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e7%9a%84>#</a></h2><p>WebRTC使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / <a href=https://tools.ietf.org/html/rfc6347>DTLS</a>）和 安全实时传输协议（Secure Real-time Transport Protocol / <a href=https://tools.ietf.org/html/rfc3711>SRTP</a>）。</p><p>DTLS使你可以协商会话，然后在两个peer之间安全地交换数据。它是TLS的同类产品，TLS是HTTPS所使用的技术，而DTLS与TLS的区别仅在与其使用UDP而不是TCP作为其传输层。这也意味着DTLS协议必须处理不可靠的数据传输。SRTP是专为安全的交换媒体数据而设计的。相对于DTLS而言，使用SRTP对传输媒体数据有一些优化。</p><p>DTLS先被使用。它通过ICE提供的连接进行一次握手。DTLS是一种客户端/服务器协议，因此其中一侧需要开始握手。客户端/服务器的角色是在信令中被确定的。在DTLS握手期间，双方都会提供证书。
握手完成后，需要将收到的证书与<code>会话描述</code>中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的WebRTC Agent。接下来，可以将DTLS连接用于DataChannel通信。</p><p>要创建SRTP会话，我们使用DTLS生成的密钥对其进行初始化。SRTP没有握手机制，因此必须使用外部密钥进行引导。一旦完成此操作，媒体数据即可以用SRTP加密并进行交换！</p><h2 id=安全性101>安全性101
<a class=anchor href=#%e5%ae%89%e5%85%a8%e6%80%a7101>#</a></h2><p>要了解本章介绍的技术，你首先需要了解这些术语。密码学是一个棘手的主题，因此其他资源也是值得参考的！</p><h4 id=明文和密文>明文和密文
<a class=anchor href=#%e6%98%8e%e6%96%87%e5%92%8c%e5%af%86%e6%96%87>#</a></h4><p>明文是cipher的输入。密文是cipher的输出。</p><h4 id=cipher>Cipher
<a class=anchor href=#cipher>#</a></h4><p>Cipher是将明文转换为密文的一系列步骤。Cipher可以反过来运行，因此你可以将密文恢复为明文。一个cipher通常拥有一个更改其行为的密钥。还有一个术语是加密和解密。</p><p>举例来说，一个简单的cipher是ROT13。也就是每个字母向前移动13个字符。要解密这个cipher，需要每个字母向后移动13个字符。明文<code>HELLO</code>将成为密文<code>URYYB</code>。 在这种情况下，Cipher是ROT，密钥是13。</p><h4 id=明文密文>明文/密文
<a class=anchor href=#%e6%98%8e%e6%96%87%e5%af%86%e6%96%87>#</a></h4><p>明文是cipher的输入。密文是cipher的输出。</p><h4 id=哈希函数>哈希函数
<a class=anchor href=#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0>#</a></h4><p>哈希函数是一种生成摘要的单向过程。给定一个输入，它每次都会生成相同的输出。其重要特点是输出<em>不</em>可逆。也就是说，根据输出的摘要，无法确定其输入。当你要确认消息未被篡改时，哈希函数很有用。</p><p>举例来说，一个简单的哈希函数的作用仅仅是将所有其他字母<code>HELLO</code>变成<code>HLO</code>。你不能认为<code>HELLO</code>就是输入，但可以确认如果输入的是<code>HELLO</code>，那么结果是匹配的。</p><h4 id=公钥私钥加密>公钥/私钥加密
<a class=anchor href=#%e5%85%ac%e9%92%a5%e7%a7%81%e9%92%a5%e5%8a%a0%e5%af%86>#</a></h4><p>公钥/私钥加密描述了DTLS和SRTP使用的cipher类型。在此系统中，你有两个密钥，即公钥和私钥。公钥用于加密消息，可以安全共享。
私钥用于解密消息，永远不应共享。当解密那些使用对应的公钥加密的消息时，它是唯一的密钥。</p><h4 id=diffie-hellman交换>Diffie-Hellman交换
<a class=anchor href=#diffie-hellman%e4%ba%a4%e6%8d%a2>#</a></h4><p>Diffie-Hellman交换允许两个以前从未见过的用户通过Internet安全的创建一个共享的秘密信息。用户<code>A</code>可以将秘密信息发送给用户<code>B</code>，而不必担心被窃听。破解该信息的难度将取决于破解离散对数问题的难度。
你不必完全理解该算法是如何工作的，但这可以帮助你了解是什么使得DTLS握手变得可行的。</p><p>Wikipedia在<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>此处</a>中有一个实际的例子。</p><h4 id=伪随机函数prf>伪随机函数（PRF）
<a class=anchor href=#%e4%bc%aa%e9%9a%8f%e6%9c%ba%e5%87%bd%e6%95%b0prf>#</a></h4><p>伪随机函数是一个预定义函数，用于生成随机出现的值。它可能需要多个输入并生成一个输出。</p><h4 id=密钥派生kdf>密钥派生（KDF）
<a class=anchor href=#%e5%af%86%e9%92%a5%e6%b4%be%e7%94%9fkdf>#</a></h4><p>密钥派生是一类伪随机函数。是一种用于增强密钥的安全性的方法。一种常见的模式是密钥扩展。</p><p>假设你获得的密钥为8字节。你可以使用KDF使其更坚固。</p><h4 id=nonce>Nonce
<a class=anchor href=#nonce>#</a></h4><p>Nonce是cipher的附加输入。这样，即使你多次加密同一条消息，也可以从cipher中获得不同的输出。</p><p>如果将同一条消息加密10次，cipher将为你提供10次相同的密文。通过使用nonce，在使用同一个密钥的情况下，你将得到不同的输入。需要注意的是，每条消息都要使用不同的nonce！ 否则就没有太大意义了。</p><h4 id=消息身份验证代码message-authentication-code>消息身份验证代码（Message Authentication Code）
<a class=anchor href=#%e6%b6%88%e6%81%af%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e4%bb%a3%e7%a0%81message-authentication-code>#</a></h4><p>消息身份验证代码（MAC）是放在消息末尾的哈希值。MAC能证明该消息来自你期望的用户。</p><p>如果你不使用MAC，攻击者可能会插入无效的消息。因为他们不知道密钥，所以这些消息解密后是无意义的垃圾内容。</p><h4 id=密钥轮换>密钥轮换
<a class=anchor href=#%e5%af%86%e9%92%a5%e8%bd%ae%e6%8d%a2>#</a></h4><p>密钥轮换是一种间隔一段时间便更改密钥的做法。这种做法会使得被窃取的密钥影响较小。如果密钥被窃取或泄漏，那么只有很少的数据可以被解密。</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS（数据报传输层安全协议）允许两个peer在没有预先存在的配置的情况下建立安全的通信。即使有人窃听了通信，他们也将无法解密消息。</p><p>为了使DTLS客户端和服务器进行通信，他们需要就cipher和密钥达成一致。他们通过进行DTLS握手来确定这些值。在握手期间，消息为纯文本格式。
当DTLS客户端/服务器交换了足够的详细信息以开始加密时，它会发送<code>Change Cipher Spec</code>（更改Cipher规格）消息。在此消息之后，后续的每个消息都将会被加密！</p><h3 id=数据包格式>数据包格式
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f>#</a></h3><p>每个DTLS数据包开头都包含一个头部信息。</p><h4 id=内容类型>内容类型
<a class=anchor href=#%e5%86%85%e5%ae%b9%e7%b1%bb%e5%9e%8b>#</a></h4><p>你可以看到数据包包括以下几种类型：</p><ul><li><code>20</code> - Change Cipher Spec（更改Cipher规格）</li><li><code>22</code> - Handshake（握手）</li><li><code>23</code> - Application Data（应用程序数据）</li></ul><p><code>握手</code>用于交换详细信息以开始会话。 <code>更改Cipher规格</code>用于通知另一端所有内容都将被加密。<code>应用程序数据</code>是加密的消息。</p><h4 id=版本>版本
<a class=anchor href=#%e7%89%88%e6%9c%ac>#</a></h4><p>版本可以是<code>0x0000feff</code>（DTLS v1.0）或<code>0x0000fefd</code>（DTLS v1.2），没有v1.1。</p><h4 id=epoch时段>Epoch（时段）
<a class=anchor href=#epoch%e6%97%b6%e6%ae%b5>#</a></h4><p>时段从<code>0</code>开始，但在<code>更改Cipher规格</code>之后变为<code>1</code>。在非零时段的任何消息都将被加密。</p><h4 id=序列号>序列号
<a class=anchor href=#%e5%ba%8f%e5%88%97%e5%8f%b7>#</a></h4><p>序列号用于保持消息顺序。每条消息都会增加序列号。当Epoch（时段）增加时，序列号重新开始。</p><h4 id=长度和有效载荷>长度和有效载荷
<a class=anchor href=#%e9%95%bf%e5%ba%a6%e5%92%8c%e6%9c%89%e6%95%88%e8%bd%bd%e8%8d%b7>#</a></h4><p>有效载荷是特定于<code>内容类型</code>的。对于<code>应用程序数据</code>而言，<code>有效载荷</code>是加密的数据。对于<code>握手</code>，它会根据消息而有所不同。长度是指<code>有效载荷</code>的大小。</p><h3 id=握手状态机><code>握手</code>状态机
<a class=anchor href=#%e6%8f%a1%e6%89%8b%e7%8a%b6%e6%80%81%e6%9c%ba>#</a></h3><p>在握手期间，客户端/服务器交换一系列消息。这些消息被分为多个Flight。每个Flight中可能有多个消息（或只有一个）。
直到收到Flight中的所有消息，该Flight才算完成。我们将在下面更详细地描述每条消息的目的。</p><p><img src=../../images/04-handshake.png alt=握手 title=握手></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello是客户端发送的初始消息。它包含一个属性列表。这些属性告诉服务器客户端支持的cipher和功能。对于WebRTC，这也是我们选择SRTP cipher方式的原因。它还包含将用于生成会话密钥的随机数据。</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>服务器将HelloVerifyRequest发送到客户端。这是为了确认客户端准备继续发送请求。然后，客户端重新发送ClientHello，但这一次需要携带HelloVerifyRequest中提供的令牌。</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello是服务器响应消息，是此次会话的配置信息。它包含此会话直到结束时将使用的cipher。它还包含服务器端的随机数据。</p><h4 id=certificate>Certificate
<a class=anchor href=#certificate>#</a></h4><p>Certificate包含客户端或服务器的证书。它被用来唯一识别我们与之通信的对方。握手结束后，我们将确保这个证书的哈希与<code>SessionDescription</code>中的指纹相匹配。</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>这些消息用于传输公共密钥。在启动时，客户端和服务器都会生成密钥对。握手后，这些值将被用来生成<code>Pre-Master Secret</code>。</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>CertificateRequest由服务端发送，用来通知客户端需要一个证书。服务端既可以请求一个证书，也可以要求必须提供证书。</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone通知客户端此时服务器已完成握手动作。</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>发送者用CertificateVerify消息来证明他已经获得了Certificate消息中发送的私钥。</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec通知接收者在此消息之后发送的所有内容都将被加密。</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished消息是加密的，它包含所有消息的哈希。用来断言握手过程未被篡改。</p><h3 id=密钥的生成>密钥的生成
<a class=anchor href=#%e5%af%86%e9%92%a5%e7%9a%84%e7%94%9f%e6%88%90>#</a></h3><p>握手完成后，你可以开始发送加密数据。Cipher是由服务器选择的，位于ServerHello消息中。但接下来如何生成密钥呢？</p><p>首先，我们需要生成<code>Pre-Master Secret</code>。为了获得该值，我们通过<code>ServerKeyExchange</code>和<code>ClientKeyExchange</code>消息，使用Diffie-Hellman算法来交换密钥。细节因选定的Cipher而异。</p><p>接下来，生成<code>Master Secret</code>。每个版本的DTLS都有一个定义的<code>Pseudorandom function</code>（伪随机函数）。对于DTLS 1.2，伪随机函数会在<code>ClientHello</code>和<code>ServerHello</code>中获取<code>Pre-Master Secret</code>和随机值。
运行<code>Pseudorandom function</code>后，获得的输出是<code>Master Secret</code>。<code>Master Secret</code>是用于Cipher的值。</p><h3 id=交换applicationdata>交换ApplicationData
<a class=anchor href=#%e4%ba%a4%e6%8d%a2applicationdata>#</a></h3><p>DTLS的主要内容是<code>ApplicationData</code>。现在我们有了一个初始化好的Cipher，我们可以开始加密和发送数据了。</p><p>如前所述，<code>ApplicationData</code>消息使用一个DTLS标头。<code>Payload</code>中填充了密文。你现在可以正常使用DTLS会话，并且可以安全地进行通信。</p><p>DTLS具有更多有趣的功能，例如重新协商等。WebRTC中不使用这些功能，因此此处不作介绍。</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP是针对加密RTP数据包专门涉及的协议。要启动SRTP会话，需要指定密钥和cipher。与DTLS不同，它没有握手机制。所有的配置和密钥都是在DTLS握手期间生成的。</p><p>DTLS提供了专用的API，用来导出密钥以供另一个进程使用。这是在<a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>中定义的</p><h3 id=会话创建>会话创建
<a class=anchor href=#%e4%bc%9a%e8%af%9d%e5%88%9b%e5%bb%ba>#</a></h3><p>SRTP定义了一个密钥派生函数，用于处理输入。在创建SRTP会话时，密钥派生函数将被执行，用输入数据生成SRTP Cipher的密钥。之后，你可以继续处理媒体。</p><h3 id=交换媒体数据>交换媒体数据
<a class=anchor href=#%e4%ba%a4%e6%8d%a2%e5%aa%92%e4%bd%93%e6%95%b0%e6%8d%ae>#</a></h3><p>每个RTP数据包都有一个16位的SequenceNumber（序列号）。这些序列号用于使数据包保持顺序，就像主键一样。在通话期间，这些序列号将滚动累加。SRTP会对其进行跟踪，并将其称为滚动计数器。</p><p>加密数据包时，SRTP使用滚动计数器和序列号作为nonce。这是为了确保即使两次发送相同的数据，密文也会有所不同。这样做很重要，可以阻止攻击者识别模式或尝试重播攻击。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/04-securing/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li class=active><a href=https://webrtcforthecurious.com/zh/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/11c7995cef03a3dee58f956ad6887fb99c97ff19 title="最后修改者 刘炎宏 | July 13, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>July 13, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.zh-cn/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#它是如何做到的>它是如何做到的？</a></li><li><a href=#安全性101>安全性101</a><ul><li></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#数据包格式>数据包格式</a></li><li><a href=#握手状态机><code>握手</code>状态机</a></li><li><a href=#密钥的生成>密钥的生成</a></li><li><a href=#交换applicationdata>交换ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#会话创建>会话创建</a></li><li><a href=#交换媒体数据>交换媒体数据</a></li></ul></li></ul></nav></div></aside></main></body></html>