<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="什么是WebRTC信令？ #  当一个WebRTC Agent被创建时，它对其他peer一无所知。它不知道它将与谁联系，也不知道它们将发送些什么！ 信令是使呼叫成为可能的初始引导程序。交换信令消息后，WebRTC Agent才可以直接相互通信。
信令消息只是文本。WebRTC Agent并不关心它们的传递方式。信令通常使用Websockets分享，但这不是必需的。
WebRTC信令如何工作？ #  WebRTC使用到一种现有的协议，称为会话描述协议（Session Description Protocol，简称SDP）。两个WebRTC Agent会将建立连接所需的所有状态通过此协议来分享。该协议本身亦易于阅读和理解。 但要理解WebRTC填充于协议中的所有值，将有一定复杂性。
该协议不是WebRTC特有的。我们将首先学习会话描述协议，这里甚至不用提及WebRTC。WebRTC实际上仅是利用了SDP协议的子集，因此我们将仅介绍我们所需的内容。 理解协议后，我们将继续结合WebRTC来说明其在实际中的应用方法。
什么是 会话描述协议（SDP）？ #  会话描述协议定义于 RFC 4566 中。它是一个key/value协议，每一行是一个值。看起来类似于INI文件。 一个会话描述包含零个或多个媒体描述。对此模型，可以理解为会话描述包含了一个媒体描述的数组。
一个媒体描述通常映射到单个媒体流。因此，如果你想描述一个包含三个视频流和两个音轨的呼叫，需要五个媒体描述。
如何阅读SDP信息 #  会话描述中的每一行都将以一个单字符开始，这是你的key。单字符后面将跟随一个等号。等号后的所有内容都是value。value结束的地方将有一个换行符。
会话描述协议定义了所有有效的key。对于协议中定义的key，你只能使用字母。这些key都有重要的意义，稍后将对此进行解释。
作为参考，下面是一个会话描述的部分内容：
a=my-sdp-value a=second-value 这里有两行。每行的key都是a。第一行的value为my-sdp-value，第二行的value为second-value。
WebRTC仅使用了部分SDP的key #  WebRTC并未使用会话描述协议定义的所有key。你当前只需要理解下面的7个key。
 v - Version，版本，版本，应等于0。 o - Origin，源，包含一个唯一ID，用于重新协商。 s - Session Name，会话名称，应等于-。 t - Timing，时间，应等于0 0。 m - Media Description(m=<media> <port> <proto> <fmt> ...)，媒体描述，下面有详细说明。 a - Attribute，属性，一个自由文本字段，这是WebRTC中最常见的行。 c - Connection Data，连接数据，应等于IN IP4 0."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="信令"><meta property="og:description" content="什么是WebRTC信令？ #  当一个WebRTC Agent被创建时，它对其他peer一无所知。它不知道它将与谁联系，也不知道它们将发送些什么！ 信令是使呼叫成为可能的初始引导程序。交换信令消息后，WebRTC Agent才可以直接相互通信。
信令消息只是文本。WebRTC Agent并不关心它们的传递方式。信令通常使用Websockets分享，但这不是必需的。
WebRTC信令如何工作？ #  WebRTC使用到一种现有的协议，称为会话描述协议（Session Description Protocol，简称SDP）。两个WebRTC Agent会将建立连接所需的所有状态通过此协议来分享。该协议本身亦易于阅读和理解。 但要理解WebRTC填充于协议中的所有值，将有一定复杂性。
该协议不是WebRTC特有的。我们将首先学习会话描述协议，这里甚至不用提及WebRTC。WebRTC实际上仅是利用了SDP协议的子集，因此我们将仅介绍我们所需的内容。 理解协议后，我们将继续结合WebRTC来说明其在实际中的应用方法。
什么是 会话描述协议（SDP）？ #  会话描述协议定义于 RFC 4566 中。它是一个key/value协议，每一行是一个值。看起来类似于INI文件。 一个会话描述包含零个或多个媒体描述。对此模型，可以理解为会话描述包含了一个媒体描述的数组。
一个媒体描述通常映射到单个媒体流。因此，如果你想描述一个包含三个视频流和两个音轨的呼叫，需要五个媒体描述。
如何阅读SDP信息 #  会话描述中的每一行都将以一个单字符开始，这是你的key。单字符后面将跟随一个等号。等号后的所有内容都是value。value结束的地方将有一个换行符。
会话描述协议定义了所有有效的key。对于协议中定义的key，你只能使用字母。这些key都有重要的意义，稍后将对此进行解释。
作为参考，下面是一个会话描述的部分内容：
a=my-sdp-value a=second-value 这里有两行。每行的key都是a。第一行的value为my-sdp-value，第二行的value为second-value。
WebRTC仅使用了部分SDP的key #  WebRTC并未使用会话描述协议定义的所有key。你当前只需要理解下面的7个key。
 v - Version，版本，版本，应等于0。 o - Origin，源，包含一个唯一ID，用于重新协商。 s - Session Name，会话名称，应等于-。 t - Timing，时间，应等于0 0。 m - Media Description(m=<media> <port> <proto> <fmt> ...)，媒体描述，下面有详细说明。 a - Attribute，属性，一个自由文本字段，这是WebRTC中最常见的行。 c - Connection Data，连接数据，应等于IN IP4 0."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/02-signaling/"><meta property="article:modified_time" content="2021-07-13T20:52:21+08:00"><meta property="og:site_name" content="给好奇者的WebRTC"><title>信令 | 给好奇者的WebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/02-signaling/ title=Signaling><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/02-signaling/ title=Signalering><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/02-signaling/ title=シグナリング><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/zh.search.min.31b81733e3578b4c232cba98b33e81297219ab93d7f490d7690bd1ffd831d040.js integrity="sha256-MbgXM+NXi0wjLLqYsz6BKXIZq5PX9JDXaQvR/9gx0EA="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/zh><span>给好奇者的WebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/02-signaling/ class=active>信令</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>连接</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>安全性</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/05-real-time-networking/>搭建实时网络</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>媒体通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>数据通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/>WebRTC应用场景</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>调试</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/11-faq/>常见问题</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>信令</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc信令如何工作>WebRTC信令如何工作？</a></li><li><a href=#什么是-会话描述协议sdp>什么是 <em>会话描述协议</em>（SDP）？</a><ul><li><a href=#如何阅读sdp信息>如何阅读SDP信息</a></li><li><a href=#webrtc仅使用了部分sdp的key>WebRTC仅使用了部分SDP的key</a></li><li><a href=#会话描述中的媒体描述>会话描述中的媒体描述</a></li><li><a href=#完整示例>完整示例</a></li></ul></li><li><a href=#会话描述协议-和webrtc如何协同工作><em>会话描述协议</em> 和WebRTC如何协同工作</a><ul><li><a href=#什么是offer和answer>什么是Offer和Answer？</a></li><li><a href=#用于发送和接收的收发器transceivers>用于发送和接收的收发器（Transceivers）</a></li><li><a href=#webrtc用到的sdp值>WebRTC用到的SDP值</a></li><li><a href=#webrtc会话描述示例>WebRTC会话描述示例</a></li><li><a href=#进一步的话题>进一步的话题</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=什么是webrtc信令>什么是WebRTC信令？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%afwebrtc%e4%bf%a1%e4%bb%a4>#</a></h1><p>当一个WebRTC Agent被创建时，它对其他peer一无所知。它不知道它将与谁联系，也不知道它们将发送些什么！
信令是使呼叫成为可能的初始引导程序。交换信令消息后，WebRTC Agent才可以直接相互通信。</p><p>信令消息只是文本。WebRTC Agent并不关心它们的传递方式。信令通常使用Websockets分享，但这不是必需的。</p><h2 id=webrtc信令如何工作>WebRTC信令如何工作？
<a class=anchor href=#webrtc%e4%bf%a1%e4%bb%a4%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c>#</a></h2><p>WebRTC使用到一种现有的协议，称为会话描述协议（Session Description Protocol，简称SDP）。两个WebRTC Agent会将建立连接所需的所有状态通过此协议来分享。该协议本身亦易于阅读和理解。
但要理解WebRTC填充于协议中的所有值，将有一定复杂性。</p><p>该协议不是WebRTC特有的。我们将首先学习会话描述协议，这里甚至不用提及WebRTC。WebRTC实际上仅是利用了SDP协议的子集，因此我们将仅介绍我们所需的内容。
理解协议后，我们将继续结合WebRTC来说明其在实际中的应用方法。</p><h2 id=什么是-会话描述协议sdp>什么是 <em>会话描述协议</em>（SDP）？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af-%e4%bc%9a%e8%af%9d%e6%8f%8f%e8%bf%b0%e5%8d%8f%e8%ae%aesdp>#</a></h2><p>会话描述协议定义于 <a href=https://tools.ietf.org/html/rfc4566>RFC 4566</a> 中。它是一个key/value协议，每一行是一个值。看起来类似于INI文件。
一个会话描述包含零个或多个媒体描述。对此模型，可以理解为会话描述包含了一个媒体描述的数组。</p><p>一个媒体描述通常映射到单个媒体流。因此，如果你想描述一个包含三个视频流和两个音轨的呼叫，需要五个媒体描述。</p><h3 id=如何阅读sdp信息>如何阅读SDP信息
<a class=anchor href=#%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bbsdp%e4%bf%a1%e6%81%af>#</a></h3><p>会话描述中的每一行都将以一个单字符开始，这是你的key。单字符后面将跟随一个等号。等号后的所有内容都是value。value结束的地方将有一个换行符。</p><p>会话描述协议定义了所有有效的key。对于协议中定义的key，你只能使用字母。这些key都有重要的意义，稍后将对此进行解释。</p><p>作为参考，下面是一个会话描述的部分内容：</p><pre><code>a=my-sdp-value
a=second-value
</code></pre><p>这里有两行。每行的key都是<code>a</code>。第一行的value为<code>my-sdp-value</code>，第二行的value为<code>second-value</code>。</p><h3 id=webrtc仅使用了部分sdp的key>WebRTC仅使用了部分SDP的key
<a class=anchor href=#webrtc%e4%bb%85%e4%bd%bf%e7%94%a8%e4%ba%86%e9%83%a8%e5%88%86sdp%e7%9a%84key>#</a></h3><p>WebRTC并未使用会话描述协议定义的所有key。你当前只需要理解下面的7个key。</p><ul><li><code>v</code> - Version，版本，版本，应等于<code>0</code>。</li><li><code>o</code> - Origin，源，包含一个唯一ID，用于重新协商。</li><li><code>s</code> - Session Name，会话名称，应等于<code>-</code>。</li><li><code>t</code> - Timing，时间，应等于<code>0 0</code>。</li><li><code>m</code> - Media Description(<code>m=&lt;media> &lt;port> &lt;proto> &lt;fmt> ...</code>)，媒体描述，下面有详细说明。</li><li><code>a</code> - Attribute，属性，一个自由文本字段，这是WebRTC中最常见的行。</li><li><code>c</code> - Connection Data，连接数据，应等于<code>IN IP4 0.0.0.0</code>。</li></ul><h3 id=会话描述中的媒体描述>会话描述中的媒体描述
<a class=anchor href=#%e4%bc%9a%e8%af%9d%e6%8f%8f%e8%bf%b0%e4%b8%ad%e7%9a%84%e5%aa%92%e4%bd%93%e6%8f%8f%e8%bf%b0>#</a></h3><p>一个会话描述中，可以包含无限数量的媒体描述。</p><p>一个媒体描述定义中，包含一个格式列表。这些格式映射到RTP有效负载类型。然后，实际的编解码器由媒体描述中的<code>rtpmap</code>属性定义。
RTP和RTP有效负载类型的重要性将在后面的媒体章节中讨论。每个媒体描述可以包含无限数量的属性。</p><p>作为参考例子，下面是一个会话描述的部分内容：</p><pre><code>v=0
m=audio 4000 RTP/AVP 111
a=rtpmap:111 OPUS/48000/2
m=video 4000 RTP/AVP 96
a=rtpmap:96 VP8/90000
a=my-sdp-value
</code></pre><p>这里面有两个媒体描述，第一个是音频，格式为<code>111</code>，另一个是视频，格式为<code>96</code>。第一个媒体描述只有一个属性。该属性将有效载荷类型<code>111</code>映射到Opus编解码器。
第二个媒体描述具有两个属性。第一个属性将有效负载类型<code>96</code>映射到VP8编解码器，第二个属性只是<code>my-sdp-value</code>。</p><blockquote class="book-hint info">译注：参照前面key的定义，第1行的v=0表示版本为0，第2/3行是第一个媒体描述，第4/5/6行是第二个媒体描述</blockquote><h3 id=完整示例>完整示例
<a class=anchor href=#%e5%ae%8c%e6%95%b4%e7%a4%ba%e4%be%8b>#</a></h3><p>以下内容将我们讨论过的所有概念整合在一起。这些是WebRTC所使用的会话描述协议的所有特性。
如果你可以读懂这个例子，那么你可以读懂任何WebRTC会话描述！</p><pre><code>v=0
o=- 0 0 IN IP4 127.0.0.1
s=-
c=IN IP4 127.0.0.1
t=0 0
m=audio 4000 RTP/AVP 111
a=rtpmap:111 OPUS/48000/2
m=video 4002 RTP/AVP 96
a=rtpmap:96 VP8/90000
</code></pre><ul><li><code>v</code>, <code>o</code>, <code>s</code>, <code>c</code>, <code>t</code> 虽然被定义，但他们不对WebRTC会话产生影响。</li><li>这里有两个媒体描述。一个是<code>audio</code>即音频类型，一个是<code>video</code>即视频类型。</li><li>每个媒体描述都有一个属性。这个属性配置了RTP管道的详细信息，这部分将在"媒体通信"章节详细讨论</li></ul><h2 id=会话描述协议-和webrtc如何协同工作><em>会话描述协议</em> 和WebRTC如何协同工作
<a class=anchor href=#%e4%bc%9a%e8%af%9d%e6%8f%8f%e8%bf%b0%e5%8d%8f%e8%ae%ae-%e5%92%8cwebrtc%e5%a6%82%e4%bd%95%e5%8d%8f%e5%90%8c%e5%b7%a5%e4%bd%9c>#</a></h2><p>下一块拼图是理解WebRTC <em>如何</em> 使用会话描述协议。</p><h3 id=什么是offer和answer>什么是Offer和Answer？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%afoffer%e5%92%8canswer>#</a></h3><p>WebRTC使用Offer/Answer模型。这指的是，一个WebRTC Agent发出"Offer"以开始呼叫，如果另一个WebRTC Agent愿意接受"Offer"的内容，它会响应"Answer&rdquo;。</p><p>这使得应答者有机会拒绝媒体描述中的某些不支持的编解码器，也是两个peer互相理解他们希望交换何种格式的方式。</p><h3 id=用于发送和接收的收发器transceivers>用于发送和接收的收发器（Transceivers）
<a class=anchor href=#%e7%94%a8%e4%ba%8e%e5%8f%91%e9%80%81%e5%92%8c%e6%8e%a5%e6%94%b6%e7%9a%84%e6%94%b6%e5%8f%91%e5%99%a8transceivers>#</a></h3><p>收发器是WebRTC中特有的概念，你将在API中看到它。它的作用是将"媒体描述"暴露给JavaScript API。每个媒体描述都将成为一个收发器。每次创建收发器时，都会将新的媒体描述添加到本地会话描述中。</p><p>WebRTC中的每个媒体描述都包含一个direction属性。这样，WebRTC Agent可以声明"我将向你发送此编解码器，但我不打算接受任何返回的内容&rdquo;。direction属性有四个有效值：</p><ul><li><code>send</code></li><li><code>recv</code></li><li><code>sendrecv</code></li><li><code>inactive</code></li></ul><h3 id=webrtc用到的sdp值>WebRTC用到的SDP值
<a class=anchor href=#webrtc%e7%94%a8%e5%88%b0%e7%9a%84sdp%e5%80%bc>#</a></h3><p>这个列表包含了你将在WebRTC Agent的会话描述中看到的一些常见属性。这些值控制着我们尚未讨论到的子系统。</p><h5 id=groupbundle><code>group:BUNDLE</code>
<a class=anchor href=#groupbundle>#</a></h5><p>BUNDLE是一种在单个连接上传输多种类型流量的行为。一些WebRTC实现对每个媒体流会使用专用的连接。但BUNDLE方式应该是首选。</p><h5 id=fingerprintsha-256><code>fingerprint:sha-256</code>
<a class=anchor href=#fingerprintsha-256>#</a></h5><p>该属性是peer用于DTLS证书的哈希值。DTLS握手完成后，你可以将其与实际证书进行比较，以确认你正在与预期的对象进行通信。</p><blockquote class="book-hint info"><p>译注：下面是<a href=https://tools.ietf.org/html/rfc4572>RFC 4572</a>中的一个例子</p><pre><code>a=fingerprint:SHA-1 \
          4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
</code></pre></blockquote><h5 id=setup><code>setup:</code>
<a class=anchor href=#setup>#</a></h5><p>该属性控制了DTLS Agent的行为。在ICE连接后，该属性将确定DTLS Agent是作为客户端还是服务器来运行。有以下几个可能的值：</p><ul><li><code>setup:active</code> - 作为DTLS客户端运行。</li><li><code>setup:passive</code> - 作为DTLS服务器运行。</li><li><code>setup:actpass</code> - 要求另一个WebRTC Agent选择。</li></ul><h5 id=ice-ufrag><code>ice-ufrag</code>
<a class=anchor href=#ice-ufrag>#</a></h5><p>该属性是ICE Agent的用户片段值。用于ICE流量的身份验证。</p><h5 id=ice-pwd><code>ice-pwd</code>
<a class=anchor href=#ice-pwd>#</a></h5><p>该属性是ICE Agent的密码。用于ICE流量的身份验证。</p><h5 id=rtpmap><code>rtpmap</code>
<a class=anchor href=#rtpmap>#</a></h5><p>该属性用于将特定的编解码器映射到RTP有效负载类型。有效负载类型不是静态的，因此对于每次呼叫，发起者都需要确定每个编解码器的有效负载类型。</p><h5 id=fmtp><code>fmtp</code>
<a class=anchor href=#fmtp>#</a></h5><p>该属性为一种有效负载类型定义附加的值。要传递特定的视频配置文件或编码器设置时，这很有用。</p><h5 id=candidate><code>candidate</code>
<a class=anchor href=#candidate>#</a></h5><p>该属性是来自ICE Agent的ICE候选地址。这是一个可能被WebRTC Agent使用的地址。这些将在下一章中详细说明。</p><h5 id=ssrc><code>ssrc</code>
<a class=anchor href=#ssrc>#</a></h5><p>一个同步源（SSRC）定义了一个单独的媒体流。</p><p><code>label</code>是此媒体流的ID。<code>mslabel</code>是容器的ID，该容器中可以有多个流。</p><h3 id=webrtc会话描述示例>WebRTC会话描述示例
<a class=anchor href=#webrtc%e4%bc%9a%e8%af%9d%e6%8f%8f%e8%bf%b0%e7%a4%ba%e4%be%8b>#</a></h3><p>下面是一个WebRTC客户端生成的一套完整会话描述：</p><pre><code>v=0
o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0
s=-
t=0 0
a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E
a=group:BUNDLE 0 1
m=audio 9 UDP/TLS/RTP/SAVPF 111
c=IN IP4 0.0.0.0
a=setup:active
a=mid:0
a=ice-ufrag:CsxzEWmoKpJyscFj
a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10;useinbandfec=1
a=ssrc:350842737 cname:yvKPspsHcYcwGFTw
a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV
a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw
a=ssrc:350842737 label:DfQnKjQQuwceLFdV
a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV
a=sendrecv
a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0
a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0
a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0
a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0
a=end-of-candidates
m=video 9 UDP/TLS/RTP/SAVPF 96
c=IN IP4 0.0.0.0
a=setup:active
a=mid:1
a=ice-ufrag:CsxzEWmoKpJyscFj
a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:96 VP8/90000
a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ
a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW
a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ
a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW
a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW
a=sendrecv
</code></pre><p>从这个会话描述中，我们可以知道以下内容：</p><ul><li>我们有两个媒体描述，一个是音频，一个是视频</li><li>这两个媒体描述都是 <code>sendrecv</code> 收发器。我们将得到两个流，也可以发送两个流回去。</li><li>我们有ICE候选地址和身份验证的详细信息，因此我们可以尝试连接</li><li>我们有一个证书指纹，因此我们可以进行安全的呼叫</li></ul><blockquote class="book-hint info"><p>译注：对照以上4点</p><ul><li>两个媒体描述即是两个<code>m=</code>段</li><li>两个m段中都有<code>a=sendrecv</code>，即是说可以收也可以发</li><li>ICE候选地址对应<code>a=candidate:foundation</code>到<code>a=end-of-candidates</code>之间的部分，身份验证信息参考前面的<code>ice-ufrag</code>和<code>ice-pwd</code>等</li><li>指的是<code>fingerprint:sha-256</code>属性</li></ul></blockquote><h3 id=进一步的话题>进一步的话题
<a class=anchor href=#%e8%bf%9b%e4%b8%80%e6%ad%a5%e7%9a%84%e8%af%9d%e9%a2%98>#</a></h3><p>在本书的后续版本中，还将讨论以下主题：</p><ul><li>重新协商（Renegotiation）</li><li>同步广播（Simulcast）</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/02-signaling/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/02-signaling/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li class=active><a href=https://webrtcforthecurious.com/zh/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/02-signaling/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/11c7995cef03a3dee58f956ad6887fb99c97ff19 title="最后修改者 刘炎宏 | July 13, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>July 13, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.zh-cn/docs/02-signaling.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc信令如何工作>WebRTC信令如何工作？</a></li><li><a href=#什么是-会话描述协议sdp>什么是 <em>会话描述协议</em>（SDP）？</a><ul><li><a href=#如何阅读sdp信息>如何阅读SDP信息</a></li><li><a href=#webrtc仅使用了部分sdp的key>WebRTC仅使用了部分SDP的key</a></li><li><a href=#会话描述中的媒体描述>会话描述中的媒体描述</a></li><li><a href=#完整示例>完整示例</a></li></ul></li><li><a href=#会话描述协议-和webrtc如何协同工作><em>会话描述协议</em> 和WebRTC如何协同工作</a><ul><li><a href=#什么是offer和answer>什么是Offer和Answer？</a></li><li><a href=#用于发送和接收的收发器transceivers>用于发送和接收的收发器（Transceivers）</a></li><li><a href=#webrtc用到的sdp值>WebRTC用到的SDP值</a></li><li><a href=#webrtc会话描述示例>WebRTC会话描述示例</a></li><li><a href=#进一步的话题>进一步的话题</a></li></ul></li></ul></nav></div></aside></main></body></html>